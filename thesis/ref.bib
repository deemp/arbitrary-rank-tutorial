% IMPORTANT
% Labels MUST contain no underscores "_". 
% Replace all non-alphanumeric characters with dashes "-".

@misc{kudasov-free-2024,
  title      = {Free Foil: Generating Efficient and Scope-Safe Abstract Syntax},
  url        = {http://arxiv.org/abs/2405.16384},
  doi        = {10.48550/arXiv.2405.16384},
  shorttitle = {Free Foil},
  abstract   = {Handling bound identifiers correctly and efficiently is critical in implementations of compilers, proof assistants, and theorem provers. When choosing a representation for abstract syntax with binders, implementors face a trade-off between type safety with intrinsic scoping, efficiency, and generality. The "foil" by Maclaurin, Radul, and Paszke combines an efficient implementation of the Barendregt convention with intrinsic scoping through advanced type system features in Haskell, such as rank-2 polymorphism and generalized algebraic data types. Free scoped monads of Kudasov, on the other hand, combine intrinsic scoping with de Bruijn indices as nested data types with Sweirstra's data types {\textbackslash}`a la carte approach to allow generic implementation of algorithms such as higher-order unification. In this paper, we suggest two approaches of making the foil more affordable. First, we marry free scoped monads with the foil, allowing to generate efficient, type-safe, and generic abstract syntax representation with binders for any language given its second-order signature. Second, we provide Template Haskell functions that allow generating the scope-safe representation from a na{\textbackslash}"ive one. The latter approach enables us to use existing tools like {BNF} Converter to very quickly prototype complete implementation of languages, including parsing, pretty-printing, and efficient intrinsically scoped abstract syntax. We demonstrate both approaches using \${\textbackslash}lambda{\textbackslash}Pi\$ with pairs and patterns as our example object language. Finally, we provide benchmarks comparing our implementation against the foil, free scoped monads with nested de Bruijn indices, and some traditional implementations.},
  number     = {{arXiv}:2405.16384},
  publisher  = {{arXiv}},
  author     = {Kudasov, Nikolai and Shakirova, Renata and Shalagin, Egor and Tyulebaeva, Karina},
  urldate    = {2024-11-11},
  date       = {2024-05-26},
  eprinttype = {arxiv},
  eprint     = {2405.16384},
  keywords   = {Computer Science - Programming Languages}
}


@article{poulsen-monadic-2023,
  title    = {A Monadic Framework for Name Resolution in Multi-phased Type Checkers},
  abstract = {An important aspect of type checking is name resolution‚Äîi.e., determining the types of names by resolving them to a matching declaration. For most languages, we can give typing rules that deÔ¨Åne name resolution in a way that abstracts from what order diÔ¨Äerent units of code should be checked in. However, implementations of type checkers in practice typically use multiple phases to ensure that declarations of resolvable names are available before names are resolved. This gives rise to a gap between typing rules that abstract from order of type checking and multi-phased type checkers that rely on explicit ordering.},
  author   = {Poulsen, Casper Bach and Zwaan, Aron and H√ºbner, Paul},
  date     = {2023},
  langid   = {english}
}


@online{free-foil-hackage,
  title      = {free-foil},
  url        = {https://hackage.haskell.org/package/free-foil},
  abstract   = {Efficient Type-Safe Capture-Avoiding Substitution for Free (Scoped Monads)},
  titleaddon = {Hackage},
  urldate    = {2025-04-25}
}


@misc{dunfield-bidirectional-2020,
  title      = {Bidirectional Typing},
  url        = {http://arxiv.org/abs/1908.05839},
  doi        = {10.48550/arXiv.1908.05839},
  number     = {{arXiv}:1908.05839},
  publisher  = {{arXiv}},
  author     = {Dunfield, Jana and Krishnaswami, Neel},
  urldate    = {2024-11-12},
  date       = {2020-11-14},
  eprinttype = {arxiv},
  eprint     = {1908.05839},
  keywords   = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science}
}


@misc{dunfield-complete-2013,
  title      = {Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism},
  url        = {http://arxiv.org/abs/1306.6032},
  doi        = {10.48550/arXiv.1306.6032},
  abstract   = {Bidirectional typechecking, in which terms either synthesize a type or are checked against a known type, has become popular for its scalability (unlike Damas-Milner type inference, bidirectional typing remains decidable even for very expressive type systems), its error reporting, and its relative ease of implementation. Following design principles from proof theory, bidirectional typing can be applied to many type constructs. The principles underlying a bidirectional approach to polymorphism, however, are less obvious. We give a declarative, bidirectional account of higher-rank polymorphism, grounded in proof theory; this calculus enjoys many properties such as eta-reduction and predictability of annotations. We give an algorithm for implementing the declarative system; our algorithm is remarkably simple and well-behaved, despite being both sound and complete.},
  number     = {{arXiv}:1306.6032},
  publisher  = {{arXiv}},
  author     = {Dunfield, Jana and Krishnaswami, Neelakantan R.},
  urldate    = {2025-04-02},
  date       = {2020-08-22},
  eprinttype = {arxiv},
  eprint     = {1306.6032 [cs]},
  keywords   = {Computer Science - Programming Languages}
}


@article{jones-practical-2007,
  title        = {Practical type inference for arbitrary-rank types},
  volume       = {17},
  rights       = {https://www.cambridge.org/core/terms},
  issn         = {0956-7968, 1469-7653},
  url          = {https://www.cambridge.org/core/product/identifier/S0956796806006034/type/journal_article},
  doi          = {10.1017/S0956796806006034},
  abstract     = {Haskell‚Äôs popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types‚Äîthat is, functions that take polymorphic functions as their arguments.},
  pages        = {1--82},
  number       = {1},
  journaltitle = {J. Funct. Prog.},
  author       = {Jones, Simon Peyton and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
  urldate      = {2025-04-03},
  date         = {2007-01},
  langid       = {english}
}


@online{ghc-trees-2022,
  title      = {Trees that grow guidance},
  url        = {https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow/trees-that-grow-guidance},
  abstract   = {The Glorious Glasgow Haskell Compiler.},
  titleaddon = {{GitLab}},
  urldate    = {2025-04-26},
  date       = {2022-01-10},
  langid     = {english}
}

@misc{trees-that-grow-2016,
  title      = {Trees That Grow},
  url        = {http://arxiv.org/abs/1610.04799},
  doi        = {10.48550/arXiv.1610.04799},
  abstract   = {We study the notion of extensibility in functional data types, as a new approach to the problem of decorating abstract syntax trees with additional sets of information. We observed the need for such extensibility while redesigning the data types representing Haskell abstract syntax inside {GHC}. Specifically, we describe our approach to the tree-decoration problem using a novel syntactic machinery in Haskell for expressing extensible data types. We show that the syntactic machinery is complete in that it can express all the syntactically possible forms of extensions to algebraic data type declarations. Then, we describe an encoding of the syntactic machinery based on the existing features in Glasgow Haskell Compiler({GHC}).},
  number     = {{arXiv}:1610.04799},
  publisher  = {{arXiv}},
  author     = {Najd, Shayan and Jones, Simon Peyton},
  urldate    = {2025-04-26},
  date       = {2016-10-15},
  eprinttype = {arxiv},
  eprint     = {1610.04799 [cs]},
  keywords   = {Computer Science - Programming Languages}
}


@online{bnfc-parser-generator,
  title   = {Welcome to {BNFC}‚Äôs documentation! ‚Äî {BNFC} 2.9.6 documentation},
  url     = {https://bnfc.digitalgrammars.com/},
  urldate = {2025-04-26}
}


@online{ghc-site-2025,
  title   = {The Glasgow Haskell Compiler},
  url     = {https://www.haskell.org/ghc/},
  urldate = {2025-04-27}
}


@online{ghc-gitlab-2025,
  title      = {Glasgow Haskell Compiler / {GHC} ¬∑ {GitLab}},
  url        = {https://gitlab.haskell.org/ghc/ghc},
  abstract   = {The Glorious Glasgow Haskell Compiler.},
  titleaddon = {{GitLab}},
  urldate    = {2025-04-27},
  date       = {2025-04-24},
  langid     = {english}
}


@online{hypertypes-hackage,
  title      = {hypertypes},
  url        = {https://hackage.haskell.org/package/hypertypes},
  abstract   = {Typed {ASTs}},
  titleaddon = {Hackage},
  urldate    = {2025-04-27}
}

@online{compdata-hackage,
  title      = {compdata},
  url        = {https://hackage.haskell.org/package/compdata},
  abstract   = {Compositional Data Types},
  titleaddon = {Hackage},
  urldate    = {2025-04-27}
}


@online{multirec-hackage,
  title      = {multirec},
  url        = {https://hackage.haskell.org/package/multirec},
  abstract   = {Generic programming for families of recursive datatypes},
  titleaddon = {Hackage},
  urldate    = {2025-04-27}
}

@article{swierstra-data-2008,
  title        = {Data types √† la carte},
  volume       = {18},
  issn         = {1469-7653, 0956-7968},
  url          = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/data-types-a-la-carte/14416CB20C4637164EA9F77097909409},
  doi          = {10.1017/S0956796808006758},
  abstract     = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell's monolithic {IO} monad.},
  pages        = {423--436},
  number       = {4},
  journaltitle = {Journal of Functional Programming},
  author       = {Swierstra, Wouter},
  urldate      = {2025-04-27},
  date         = {2008-07},
  langid       = {english}
}


@online{lens-hackage,
  title      = {lens},
  url        = {https://hackage.haskell.org/package/lens},
  abstract   = {Lenses, Folds and Traversals},
  titleaddon = {Hackage},
  urldate    = {2025-04-27}
}


@software{deemp-higher-rank-free-foil,
  title    = {deemp/higher-rank-free-foil},
  url      = {https://github.com/deemp/higher-rank-free-foil},
  abstract = {A repository for the MS thesis Type Inference for arbitrary-rank types using Free Foil},
  author   = {Danko, Danila},
  urldate  = {2025-04-27},
  date     = {2025-04-27},
  note     = {original-date: 2024-11-11T16:24:27Z}
}


@article{practical-type-inference-proofs,
  url    = {https://repository.upenn.edu/server/api/core/bitstreams/7c1dc678-93c6-4516-98fd-f82b384eb75d/content},
  title  = {Practical type inference for arbitrary-rank types - Technical Appendix},
  author = {Vytiniotis, Dimitrios and Weirich, Stephanie and Peyton-Jones, Simon},
  langid = {english}
}


@misc{selinger-lecture-2013,
  title      = {Lecture notes on the lambda calculus},
  url        = {http://arxiv.org/abs/0804.3434},
  doi        = {10.48550/arXiv.0804.3434},
  abstract   = {This is a set of lecture notes that developed out of courses on the lambda calculus that I taught at the University of Ottawa in 2001 and at Dalhousie University in 2007 and 2013. Topics covered in these notes include the untyped lambda calculus, the Church-Rosser theorem, combinatory algebras, the simply-typed lambda calculus, the Curry-Howard isomorphism, weak and strong normalization, polymorphism, type inference, denotational semantics, complete partial orders, and the language {PCF}.},
  number     = {{arXiv}:0804.3434},
  publisher  = {{arXiv}},
  author     = {Selinger, Peter},
  urldate    = {2025-04-28},
  date       = {2013-12-26},
  eprinttype = {arxiv},
  eprint     = {0804.3434 [cs]},
  keywords   = {Computer Science - Logic in Computer Science}
}


@article{dunfield-sound-2019,
  title        = {Sound and complete bidirectional typechecking for higher-rank polymorphism with existentials and indexed types},
  volume       = {3},
  url          = {https://dl.acm.org/doi/10.1145/3290322},
  doi          = {10.1145/3290322},
  abstract     = {Bidirectional typechecking, in which terms either synthesize a type or are checked against a known type, has become popular for its applicability to a variety of type systems, its error reporting, and its ease of implementation. Following principles from proof theory, bidirectional typing can be applied to many type constructs. The principles underlying a bidirectional approach to indexed types (generalized algebraic datatypes) are less clear. Building on proof-theoretic treatments of equality, we give a declarative specification of typing based on focalization. This approach permits declarative rules for coverage of pattern matching, as well as support for first-class existential types using a focalized subtyping judgment. We use refinement types to avoid explicitly passing equality proofs in our term syntax, making our calculus similar to languages such as Haskell and {OCaml}. We also extend the declarative specification with an explicit rules for deducing when a type is principal, permitting us to give a complete declarative specification for a rich type system with significant type inference. We also give a set of algorithmic typing rules, and prove that it is sound and complete with respect to the declarative system. The proof requires a number of technical innovations, including proving soundness and completeness in a mutually recursive fashion.},
  pages        = {9:1--9:28},
  issue        = {{POPL}},
  journaltitle = {Proc. {ACM} Program. Lang.},
  author       = {Dunfield, Jana and Krishnaswami, Neelakantan R.},
  urldate      = {2025-04-03},
  date         = {2019-01-02}
}


@software{github-choi-kwanghoonbidi-2025,
  title    = {kwanghoon/bidi},
  rights   = {{BSD}-3-Clause},
  url      = {https://github.com/kwanghoon/bidi},
  abstract = {bidirectional type checking algorithms for higher-ranked polymorphism},
  author   = {Choi, Kwanghoon},
  urldate  = {2025-04-28},
  date     = {2025-01-03},
  note     = {original-date: 2020-08-16T11:54:57Z},
  keywords = {bidirectional-typechecking, functional-programming, haskell, higher-rank-types, typeinference, types}
}

@software{github-goldenberg-artem-goldenbergbidirectionalsystem-2025,
  title    = {Artem-Goldenberg/{BidirectionalSystem}},
  url      = {https://github.com/Artem-Goldenberg/BidirectionalSystem},
  abstract = {Implementation of higher-rank polymorphic type inference with user supplied annotations},
  author   = {Goldenberg, Artem},
  urldate  = {2025-04-28},
  date     = {2025-01-23},
  note     = {original-date: 2024-11-23T14:06:35Z}
}

@software{github-chen-cu1ch3ntype-inference-zoo-2025,
  title    = {cu1ch3n/type-inference-zoo},
  rights   = {{MIT}},
  url      = {https://github.com/cu1ch3n/type-inference-zoo},
  abstract = {ü¶ñ Implementations of various type inference algorithms. Online interactive playground is available at https://zoo.cuichen.cc/},
  author   = {Chen, Cui},
  urldate  = {2025-04-28},
  date     = {2025-04-26},
  note     = {original-date: 2024-12-27T09:05:39Z},
  keywords = {functional-programming, haskell, programming-languages, type-inference, zoo}
}

@article{xie-higher-rank,
  title  = {Higher-rank Polymorphism: Type Inference and Extensions},
  url    = {https://i.cs.hku.hk/~bruno/thesis/NingningXie.pdf},
  author = {Xie, Ningning},
  langid = {english}
}


@article{xue-contextual-2024,
  title        = {Contextual Typing},
  volume       = {8},
  issn         = {2475-1421},
  url          = {https://dl.acm.org/doi/10.1145/3674655},
  doi          = {10.1145/3674655},
  pages        = {880--908},
  issue        = {{ICFP}},
  journaltitle = {Proc. {ACM} Program. Lang.},
  author       = {Xue, Xu and Oliveira, Bruno C. D. S.},
  urldate      = {2025-04-04},
  date         = {2024-08-15},
  langid       = {english}
}


@article{parreaux-when-2024,
  title        = {When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism},
  volume       = {8},
  issn         = {2475-1421},
  url          = {https://dl.acm.org/doi/10.1145/3632890},
  doi          = {10.1145/3632890},
  shorttitle   = {When Subtyping Constraints Liberate},
  pages        = {1418--1450},
  issue        = {{POPL}},
  journaltitle = {Proc. {ACM} Program. Lang.},
  author       = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
  urldate      = {2025-04-24},
  date         = {2024-01-05},
  langid       = {english}
}


@inproceedings{eisenberg-stitch-2020,
  location   = {Virtual Event {USA}},
  title      = {Stitch: the sound type-indexed type checker (functional pearl)},
  isbn       = {978-1-4503-8050-8},
  url        = {https://dl.acm.org/doi/10.1145/3406088.3409015},
  doi        = {10.1145/3406088.3409015},
  shorttitle = {Stitch},
  abstract   = {A classic example of the power of generalized algebraic datatypes ({GADTs}) to verify a delicate implementation is the type-indexed expression {AST}. This functional pearl refreshes this example, casting it in modern Haskell using many of {GHC}‚Äôs bells and whistles. The Stitch interpreter is a full executable interpreter, with a parser, type checker, commonsubexpression elimination, and a {REPL}. Making heavy use of {GADTs} and type indices, the Stitch implementation is clean Haskell code and serves as an existence proof that Haskell‚Äôs type system is advanced enough for the use of fancy types in a practical setting. The paper focuses on guiding the reader through these advanced topics, enabling them to adopt the techniques demonstrated here.},
  eventtitle = {{ICFP} '20: {ACM} {SIGPLAN} International Conference on Functional Programming},
  pages      = {39--53},
  booktitle  = {Proceedings of the 13th {ACM} {SIGPLAN} International Symposium on Haskell},
  publisher  = {{ACM}},
  author     = {Eisenberg, Richard A.},
  urldate    = {2025-04-27},
  date       = {2020-08-27},
  langid     = {english}
}


@article{trees-that-grow-2016,
	title = {Trees that Grow},
	volume = {23},
	rights = {2017 Shayan Najd, Simon Jones},
	issn = {0948-6968},
	url = {https://lib.jucs.org/article/22912/},
	doi = {10.3217/jucs-023-01-0042},
	abstract = {We study the notion of extensibility in functional data types, as a new approach to the problem of decorating abstract syntax trees with additional information. We observed the need for such extensibility while redesigning the data types representing Haskell abstract syntax inside Glasgow Haskell Compiler ({GHC}). Specifically, we describe a programming idiom that exploits type-level functions to allow a particular form of extensibility. The approach scales to support existentials and generalised algebraic data types, and we can use pattern synonyms to make it convenient in practice.},
	pages = {42--62},
	number = {1},
	journaltitle = {{JUCS} - Journal of Universal Computer Science},
	author = {Najd, Shayan and Jones, Simon},
	urldate = {2025-04-28},
	date = {2017-01-28},
	langid = {english},
	note = {Number: 1 Publisher: Journal of Universal Computer Science},
}


@book{pierce-types-2002,
	edition = {1st},
	title = {Types and Programming Languages},
	isbn = {978-0-262-16209-8},
	abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.},
	pagetotal = {645},
	publisher = {The {MIT} Press},
	author = {Pierce, Benjamin C.},
	date = {2002-01},
}


@online{jones-typechecker-2023,
	title = {Secrets of the {GHC} Typechecker in 100 Type Declarations},
	url = {https://simon.peytonjones.org/secrets-of-typechecker/},
	abstract = {Simon Peyton Jones Video of talk at the {GHC} Contributors Workshop, June 2023  Video Slides},
	titleaddon = {Simon Peyton Jones},
	author = {Jones, Simon Peyton},
	urldate = {2025-05-06},
	date = {2023-06-01},
	langid = {english},
}


@article{jones-rapier-2002,
	title = {Secrets of the Glasgow Haskell Compiler inliner},
	volume = {12},
	rights = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796802004331/type/journal_article},
	doi = {10.1017/s0956796802004331},
	abstract = {Higher-order languages, such as Haskell, encourage the programmer to build abstractions by composing functions. A good compiler must inline many of these calls to recover an e ciently executable program.},
	pages = {393--434},
	number = {4},
	journaltitle = {J. Funct. Prog.},
	author = {Peyton Jones, Simon and Marlow, Simon},
	urldate = {2025-05-01},
	date = {2002-07},
	langid = {english},
	note = {Publisher: Cambridge University Press ({CUP})},
}


@software{github-hkust-taco-superf-2025,
	title = {hkust-taco/superf},
	rights = {{MIT}},
	url = {https://github.com/hkust-taco/superf},
	abstract = {Artifact for paper "When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism" (https://popl24.sigplan.org/details/{POPL}-2024-popl-research-papers/50)},
	publisher = {{HKUST} {TACO} Lab},
	urldate = {2025-05-06},
	date = {2025-04-24},
	note = {original-date: 2023-05-09T03:58:10Z},
}


@online{github-hkust-taco-mlscript-2025,
	title = {hkust-taco/mlscript: The {MLscript} programming language. Functional and object-oriented; structurally typed and sound; with powerful type inference. Soon to have full interop with {TypeScript}!},
	url = {https://github.com/hkust-taco/mlscript},
	urldate = {2025-05-06},
	file = {hkust-taco/mlscript\: The MLscript programming language. Functional and object-oriented\; structurally typed and sound\; with powerful type inference. Soon to have full interop with TypeScript!:/home/eyjafjallajokull/Zotero/storage/3NKAWCGH/mlscript.html:text/html},
}

