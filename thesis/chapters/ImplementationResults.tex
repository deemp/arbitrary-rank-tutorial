\chapter{Implementation and Results}
\label{chap:ImplementationAndResults}

The previous chapter detailed the architectural design and core methodologies for the \texttt{Arralac} compiler. This chapter transitions from design to practice, describing the concrete Haskell implementation that realizes this architecture.

First, I will examine the implementation of the core data structures, particularly the Trees That Grow (TTG) Abstract Syntax Tree (AST). Next, I will detail the implementation of the type inference pipeline, focusing on the separation between constraint generation and solving. Finally, I will present concrete results, including the output of the typechecker and evaluator for a sample program and a demonstration of the functional Language Server Protocol (LSP) features.

\section{AST Implementation with Trees That Grow}
\label{sec:Implementation:AST}

As outlined in the design (\cref{sec:Design:AST}), the AST is built using the Trees That Grow (TTG) pattern to ensure extensibility and to facilitate annotations. The core data types, \texttt{SynTerm} for expressions and \texttt{SynType} for syntactic types, are parameterized by a type variable \texttt{x} that represents the current compiler pass (e.g., \texttt{CompRn} for Renamed, \texttt{CompTc} for Typechecked).

Unlike a simpler AST where fields have concrete types, every component of an \texttt{Arralac} AST node is defined by a type family. This allows the structure of a node to be radically different across passes. For example, the definition for \texttt{SynTerm} in the module \texttt{Language.Arralac.Syntax.TTG.SynTerm} is shown below.

\begin{minted}[frame=lines,label={The Generic `SynTerm` Data Type}]{haskell}
data SynTerm x
  = -- | \ (x :: a) -> x
    SynTerm'ALam (XSynTerm'ALam' x) (XSynTerm'ALam'Var x) 
                 (XSynTerm'ALam'Type x) (XSynTerm'ALam'Body x)
  | -- | (f x) :: Int
    SynTerm'Ann (XSynTerm'Ann' x) (XSynTerm'Ann'Term x) 
                (XSynTerm'Ann'Type x)
  -- ... other constructors
\end{minted}

These type families are then instantiated for each specific compiler pass. For the typechecking pass (\texttt{CompTc}), the extension point fields (e.g., \texttt{XSynTerm'Ann'}) are instantiated with a \texttt{TcAnno} record, which crucially contains the inferred type for that node. This demonstrates how the tree "grows" to hold new information.

\begin{minted}[frame=lines,label={Type Family Instantiation for the `Typechecked` Pass}]{haskell}
-- In Language.Arralac.Syntax.Local.SynTerm.Tc
type instance XSynTerm'Ann'Term CompTc = SynTerm CompTc
type instance XSynTerm'Ann'Type CompTc = SynType CompTc

-- In Language.Arralac.Syntax.Local.Extension.Tc
type instance XSynTerm'Ann' CompTc = TcAnno
data TcAnno = TcAnno { annoSrcLoc :: SrcSpan, annoType :: Expected TcType }
\end{minted}

This approach provides a type-safe way to ensure that pass-specific information, such as inferred types, is only available in the AST after that pass has successfully completed.

\section{The Type Inference and Solving Pipeline}
\label{sec:Implementation:Pipeline}

The implementation of the type inference engine closely follows the constraint-based design laid out in \cref{sec:Design:TypeInference}. The process is divided into distinct, sequential stages, each managed by its own set of modules.

\subsection{Constraint Generation (`Typechecker`)}
The first phase, implemented primarily in the \texttt{Language.Arralac.Typechecker.TcTerm} module, traverses the renamed AST to produce a set of wanted constraints. It does not perform any unification itself.
\begin{itemize}
  \item \textbf{Bidirectional Logic:} The core function, \texttt{tcRho}, implements the bidirectional algorithm. When called in inference mode (via the \texttt{inferRho} wrapper), it creates a new IORef to hold the resulting type. When called in checking mode (via \texttt{checkRho}), it consumes the expected type passed to it.

  \item \textbf{Implication Constraints:} At each point where skolemization is required---specifically, within the \texttt{checkSigma} function when checking an expression against a polymorphic type---the typechecker enters a deeper scope. This is implemented by the \texttt{pushLevelAndCaptureConstraints} helper function, which increments the current \texttt{TcLevel}, captures all new constraints generated within its scope, and packages them into an \texttt{Implic} constraint.
\end{itemize}

\subsection{Constraint Solving (`Solver`)}
The set of \texttt{WantedConstraints} generated by the typechecker is passed to the solver, implemented in \texttt{Language.Arralac.Solver.Solve}. The solver iteratively processes the worklist of simple equality constraints (\texttt{wc\_simple}).
\begin{itemize}
  \item \textbf{Occurs and Level Checks:} Before attempting to unify a metavariable with a type, the solver performs two critical checks, implemented in \texttt{Language.Arralac.Solver.Check}. First, an \textbf{occurs check} ensures the metavariable does not appear within the right-hand side of the type, preventing infinite types. Second, a \textbf{level check} verifies that the type does not contain any skolem variables with a level deeper than the metavariable, thus enforcing the skolem escape rule.
  \item \textbf{Unification:} If the checks pass, the solver unifies the variable by writing to the metavariable's mutable reference (\texttt{IORef}). Constraints within implications are solved recursively within their own scope. Any constraints that cannot be solved (e.g., due to a type mismatch or a failed check) are currently dropped, and their metavariables remain unsolved.
\end{itemize}

\subsection{Finalization (`Zonker`)}
After the solver has completed, the \texttt{Zonker}, implemented in \texttt{Language.Arralac.Zonker.Zn.Zonk}, traverses the now-typed AST. It recursively resolves the \texttt{IORef} of each metavariable, replacing it with its final, unified type. Metavariables that were not solved are explicitly renamed to indicate their status (e.g., `a_Unsolved_11`), producing a final AST that is free of mutable references and ready for code generation or evaluation.

\section{Results and System Characteristics}
\label{sec:Implementation:Results}

This section demonstrates the functionality of the implemented system using a concrete example and evaluates its characteristics based on the criteria from the thesis guidelines.

\subsection{A Complete Example}
To test the core functionality, I use a program that requires arbitrary-rank polymorphism: passing a polymorphic function as an argument. The following program, \texttt{Program1.arralac}, defines a function \texttt{applyMyShow} that expects a polymorphic function of type \texttt{forall b. b -> String} and applies it to a value.

\begin{minted}[frame=lines,label={Program1.arralac}]{haskell}
let
  applyMyShow =
    (\x. \y. x y)
      :: forall a. (forall b. b -> String) -> a -> String
in
let
  myShow = \x. "Hello"
in
applyMyShow myShow
\end{minted}

\subsection{Type Checking and Evaluation}
Running the \texttt{Arralac} CLI to typecheck the program produces a fully-annotated and pretty-printed AST. The output below shows that the system correctly inferred and propagated the types, including the higher-rank type of the lambda-bound variable \texttt{x\_1}.

\begin{figure}[h]
  \centering
  \begin{minted}[frame=lines]{console}
$ nix run .#arralac -- typecheck arralac/test/data/Program1.arralac

(let
  applyMyShow_0 = 
    (\(x_1 :: forall b_4. b_4 -> String).
       (\(y_2 :: a_9). (x_1 :: a_9 -> String) (y_2 :: a_9) :: String
       ) :: a_9 -> String
    ) :: (forall b_4. b_4 -> String) -> a_9 -> String
in
  (let myShow_7 = (\(x_8 :: b_13). "Hello") :: b_13 -> String
   in (applyMyShow_0 (myShow_7)) :: a_Unsolved_11 -> String
  ) :: a_Unsolved_11 -> String
) :: a_Unsolved_11 -> String
\end{minted}
  \caption{Typechecking output for \texttt{Program1.arralac}.}
  \label{fig:typecheck-output}
\end{figure}

Note the final type includes \texttt{a\_Unsolved\_11}, correctly indicating that the type variable \texttt{a} from the original signature was not constrained and thus remains unsolved.

The evaluator correctly reduces the program to its weak head normal form (WHNF):

\begin{figure}
  \centering
  \begin{minted}[frame=lines]{console}
$ nix run .#arralac -- evaluate whnf arralac/test/data/Program1.arralac

\y_2. (\x_8. "Hello") (y_2)
\end{minted}
  \caption{Evaluation Output for \texttt{Program1.arralac}.}
  \label{fig:evaluate-output}
\end{figure}

\subsection{Language Server Functionality}
The implementation includes a functional language server that provides on-the-fly diagnostics and type information. \Cref{fig:lsp-demo} demonstrates two key features in Visual Studio Code: (1) hovering over an identifier (\texttt{applyMyShow}) to see its inferred polymorphic type, and (2) an error diagnostic for an unbound variable (\texttt{myShowww}).

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.9\textwidth]{VSCode.png}
  \caption{LSP features: type on hover and error diagnostics.}
  \label{fig:lsp-demo}
\end{figure}

\subsection{Codebase Characteristics}
The system was evaluated against several quality characteristics from ISO 25010.
\begin{itemize}
  \item \textbf{Modularity:} The codebase is highly modular, comprising 86 distinct Haskell modules, as shown by the \texttt{cloc} \footnote{The tool is available at \url{https://github.com/AlDanial/cloc}} analysis in \cref{table:cloc}. This separation of concerns was critical for managing the complexity of the type inference engine.
  \item \textbf{Analysability:} The error-handling mechanism is designed for clear diagnostics. Each pipeline stage (e.g., Renamer, Typechecker, Solver) throws its own distinct error type, which captures a full call stack. This ensures that failures are easy to trace back to their source.
  \item \textbf{Installability:} The entire project is packaged with Nix, enabling a reproducible, single-line installation via the command \texttt{nix profile install}.
\end{itemize}

\begin{table}[h!]
  \centering
  \begin{center}
    \textsc{TABLE I} \\ % Use \textsc for small caps if desired, or just TABLE I
    \vspace{0.1cm} % Small space between label and caption
    Code Metrics for the \texttt{Arralac} Implementation \\
    Generated by \texttt{cloc}
  \end{center}
  \begin{tabular}{lrrrr}
    \toprule
    \textbf{Language} & \textbf{Files} & \textbf{Blank Lines} & \textbf{Comment Lines} & \textbf{Code Lines} \\
    \midrule
    Haskell           & 86             & 705                  & 1085                   & 3907                \\
    \midrule
    \textbf{SUM}      & \textbf{86}    & \textbf{705}         & \textbf{1085}          & \textbf{3907}       \\
    \bottomrule
  \end{tabular}
\label{table:cloc}
\end{table}

This chapter has demonstrated that the design laid out previously has been successfully realized in a functional, well-structured, and non-trivial implementation. The system correctly handles higher-rank types and provides modern tooling, fulfilling the primary objectives of this thesis.