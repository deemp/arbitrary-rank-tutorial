\begin{abstract}

    Advanced type systems, such as arbitrary-rank polymorphism, are powerful but notoriously difficult to implement, creating a pedagogical gap between seminal theory, like that of Peyton Jones et al., and complex production compilers like the Glasgow Haskell Compiler (GHC). This thesis addresses this gap by presenting \Arralac, a small, tutorial-focused compiler for a lambda calculus with arbitrary-rank polymorphism. Rather than replicating the eager unification algorithm of foundational papers, \Arralac implements a modern, GHC-style, two-phase architecture that cleanly separates constraint generation from constraint solving, demonstrating a more modular and pedagogically clear approach. This design is supported by a Trees That Grow (TTG) Abstract Syntax Tree (AST), which enables pass-specific annotations crucial for tooling. The system is delivered as a complete, interactive toolchain, featuring a Language Server Protocol (LSP) implementation that makes the internal state of the typechecker transparent and explorable within a code editor. The implementation is validated by its ability to correctly handle higher-rank types, reject invalid programs through level-based skolem escape checks, and ultimately demonstrates that a constraint-based model serves as a clearer instructional tool than its eager counterpart. By synthesizing foundational theory with modern engineering patterns and interactive feedback, \Arralac provides an accessible and effective resource that demystifies a cornerstone of advanced compiler design.

\end{abstract}