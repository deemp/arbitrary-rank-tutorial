\looseness=-1
\chapter{Conclusion}
\label{chap:Conclusion}

This thesis was motivated by a significant pedagogical gap between the foundational theory of advanced type systems and the complex reality of their production-grade implementations. I began with the central claim that this gap could be bridged not by yet another theoretical paper, but by a modern, tutorial-focused compiler that makes the core engineering principles of a system like GHC tangible and interactive. The design and implementation of \texttt{Arralac}, a lambda calculus with arbitrary-rank polymorphism, has served to validate this thesis.

To achieve this, \texttt{Arralac} was built upon a synthesis of carefully chosen architectural patterns. By integrating a modular, constraint-based type inference pipeline with an extensible Trees That Grow AST, the project established a foundation that is both robust and clear. This architecture was then brought to life through a complete toolchain, most notably a functional Language Server Protocol (LSP) implementation, which transforms the abstract algorithms of type inference into an explorable, interactive experience.

The development of \texttt{Arralac} yielded a key insight: the architectural choices made in a compiler's design have a profound and direct impact on its pedagogical value. The separation of constraint generation from solving does not merely improve modularity; it creates an explicit representation of the typechecker's "reasoning" that can be inspected and understood in an easier way that an eager algorithm. Similarly, the use of the LSP confirms that modern tooling is a transformative element in computer science education. Providing on-the-fly type information and diagnostics directly within an editor makes the behavior of the type system immediately visible, turning abstract rules into concrete feedback.

While \texttt{Arralac} successfully demonstrates its core thesis, its journey as a practical tool is far from complete. The logical next step is to tackle the crucial feature of \texttt{let}-generalization, a challenge for which the existing constraint-based architecture is an ideal foundation. Subsequently, evolving the evaluator to use a typed Core language would introduce the end-to-end type safety characteristic of production compilers. Extending the language server to support richer features, such as "go to definition," would further enhance its utility as a development and learning environment.

      
\enlargethispage{\baselineskip}
This thesis began with the goal of demystifying the "magic" of a production-grade type system. Through the design and implementation of \texttt{Arralac}, it has shown that the core principles of arbitrary-rank polymorphism can be implemented in a structured, modern, and understandable way. By combining foundational theory with practical architectural patterns, this work provides a clear and interactive bridge for students, researchers, and aspiring language developers. Ultimately, this project stands as a testament to the idea that even the most powerful compiler technologies can be made accessible, fostering a deeper understanding and appreciation for the art of programming language implementation.