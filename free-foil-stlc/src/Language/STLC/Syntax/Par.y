-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.STLC.Syntax.Par
  ( happyError
  , myLexer
  , pProgram
  , pVar
  , pStatement
  , pListStatement
  , pSynthResult
  , pExp1
  , pExp2
  , pExp3
  , pExp4
  , pExp5
  , pExp6
  , pExp
  , pExp10
  , pExp11
  , pType1
  , pType2
  , pType3
  , pType
  , pCtxVar
  , pListCtxVar
  , pCtx
  , pExpUnderCtx
  ) where

import Prelude

import qualified Language.STLC.Syntax.Abs
import Language.STLC.Syntax.Lex

}

%name pProgram_internal Program
%name pVar_internal Var
%name pStatement_internal Statement
%name pListStatement_internal ListStatement
%name pSynthResult_internal SynthResult
%name pExp1_internal Exp1
%name pExp2_internal Exp2
%name pExp3_internal Exp3
%name pExp4_internal Exp4
%name pExp5_internal Exp5
%name pExp6_internal Exp6
%name pExp_internal Exp
%name pExp10_internal Exp10
%name pExp11_internal Exp11
%name pType1_internal Type1
%name pType2_internal Type2
%name pType3_internal Type3
%name pType_internal Type
%name pCtxVar_internal CtxVar
%name pListCtxVar_internal ListCtxVar
%name pCtx_internal Ctx
%name pExpUnderCtx_internal ExpUnderCtx
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#typecheck'    { PT _ (TS _ 1)            }
  '#typesynth'    { PT _ (TS _ 2)            }
  '('             { PT _ (TS _ 3)            }
  ')'             { PT _ (TS _ 4)            }
  '+'             { PT _ (TS _ 5)            }
  ','             { PT _ (TS _ 6)            }
  '->'            { PT _ (TS _ 7)            }
  '.'             { PT _ (TS _ 8)            }
  ':'             { PT _ (TS _ 9)            }
  ';'             { PT _ (TS _ 10)           }
  '<='            { PT _ (TS _ 11)           }
  '='             { PT _ (TS _ 12)           }
  '=>'            { PT _ (TS _ 13)           }
  '?'             { PT _ (TS _ 14)           }
  '\\'            { PT _ (TS _ 15)           }
  'else'          { PT _ (TS _ 16)           }
  'forall'        { PT _ (TS _ 17)           }
  'if'            { PT _ (TS _ 18)           }
  'then'          { PT _ (TS _ 19)           }
  'where'         { PT _ (TS _ 20)           }
  '{'             { PT _ (TS _ 21)           }
  '|-'            { PT _ (TS _ 22)           }
  '}'             { PT _ (TS _ 23)           }
  L_integ         { PT _ (TI _)              }
  L_NameLowerCase { PT _ (T_NameLowerCase _) }
  L_NameUpperCase { PT _ (T_NameUpperCase _) }

%%

Integer :: { (Language.STLC.Syntax.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

NameLowerCase :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.NameLowerCase) }
NameLowerCase  : L_NameLowerCase { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.NameLowerCase (tokenText $1)) }

NameUpperCase :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.NameUpperCase) }
NameUpperCase  : L_NameUpperCase { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.NameUpperCase (tokenText $1)) }

Program :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Program) }
Program
  : ListStatement { (fst $1, Language.STLC.Syntax.Abs.Program (fst $1) (snd $1)) }

Var :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Var) }
Var
  : NameLowerCase { (fst $1, Language.STLC.Syntax.Abs.Var (fst $1) (snd $1)) }

Statement :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Statement) }
Statement
  : Var ':' Type { (fst $1, Language.STLC.Syntax.Abs.StatementFunSig (fst $1) (snd $1) (snd $3)) }
  | Var '=' Exp { (fst $1, Language.STLC.Syntax.Abs.StatementFun (fst $1) (snd $1) (snd $3)) }
  | Var '=' Exp 'where' '{' ListStatement '}' { (fst $1, Language.STLC.Syntax.Abs.StatementFunWhere (fst $1) (snd $1) (snd $3) (snd $6)) }
  | '#typecheck' ExpUnderCtx '<=' Type { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementCommandTypeCheck (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '#typesynth' ExpUnderCtx '=>' SynthResult { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementCommandTypeSynth (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListStatement :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.Statement]) }
ListStatement
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | Statement { (fst $1, (:[]) (snd $1)) }
  | Statement ';' ListStatement { (fst $1, (:) (snd $1) (snd $3)) }

SynthResult :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.SynthResult) }
SynthResult
  : Type { (fst $1, Language.STLC.Syntax.Abs.SynthResultType (fst $1) (snd $1)) }
  | '?' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.SynthResultUnknown (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }

Exp1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp1
  : Var { (fst $1, Language.STLC.Syntax.Abs.ExpVar (fst $1) (snd $1)) }

Exp2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp2
  : Integer { (fst $1, Language.STLC.Syntax.Abs.ExpNumber (fst $1) (snd $1)) }

Exp3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp3
  : Exp10 '+' Exp10 { (fst $1, Language.STLC.Syntax.Abs.ExpPlus (fst $1) (snd $1) (snd $3)) }

Exp4 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp4
  : '\\' Var '->' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpAbs (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

Exp5 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp5
  : Exp11 Exp10 { (fst $1, Language.STLC.Syntax.Abs.ExpApp (fst $1) (snd $1) (snd $2)) }

Exp6 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp6
  : 'if' '(' Exp ')' 'then' '{' Exp '}' 'else' '{' Exp '}' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpIfThenElse (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $7) (snd $11)) }

Exp :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp
  : Exp1 { (fst $1, (snd $1)) }
  | Exp2 { (fst $1, (snd $1)) }
  | Exp3 { (fst $1, (snd $1)) }
  | Exp4 { (fst $1, (snd $1)) }
  | Exp5 { (fst $1, (snd $1)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp10 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp10
  : Exp1 { (fst $1, (snd $1)) }
  | Exp2 { (fst $1, (snd $1)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp11 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp11
  : Exp1 { (fst $1, (snd $1)) }
  | Exp5 { (fst $1, (snd $1)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type1
  : NameUpperCase { (fst $1, Language.STLC.Syntax.Abs.TypeName (fst $1) (snd $1)) }
  | Type2 { (fst $1, (snd $1)) }

Type2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type2
  : 'forall' Var '.' Type { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TypeForall (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Type3 { (fst $1, (snd $1)) }

Type3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type3
  : Type '->' Type { (fst $1, Language.STLC.Syntax.Abs.TypeFunc (fst $1) (snd $1) (snd $3)) }
  | '(' Type ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type : Type1 { (fst $1, (snd $1)) }

CtxVar :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.CtxVar) }
CtxVar
  : Var ':' Type { (fst $1, Language.STLC.Syntax.Abs.CtxVar (fst $1) (snd $1) (snd $3)) }

ListCtxVar :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.CtxVar]) }
ListCtxVar
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | CtxVar { (fst $1, (:[]) (snd $1)) }
  | CtxVar ',' ListCtxVar { (fst $1, (:) (snd $1) (snd $3)) }

Ctx :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Ctx) }
Ctx
  : ListCtxVar { (fst $1, Language.STLC.Syntax.Abs.Ctx (fst $1) (snd $1)) }

ExpUnderCtx :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ExpUnderCtx) }
ExpUnderCtx
  : Ctx '|-' Exp { (fst $1, Language.STLC.Syntax.Abs.ExpUnderCtx (fst $1) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Language.STLC.Syntax.Abs.Program
pProgram = fmap snd . pProgram_internal

pVar :: [Token] -> Err Language.STLC.Syntax.Abs.Var
pVar = fmap snd . pVar_internal

pStatement :: [Token] -> Err Language.STLC.Syntax.Abs.Statement
pStatement = fmap snd . pStatement_internal

pListStatement :: [Token] -> Err [Language.STLC.Syntax.Abs.Statement]
pListStatement = fmap snd . pListStatement_internal

pSynthResult :: [Token] -> Err Language.STLC.Syntax.Abs.SynthResult
pSynthResult = fmap snd . pSynthResult_internal

pExp1 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp1 = fmap snd . pExp1_internal

pExp2 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp2 = fmap snd . pExp2_internal

pExp3 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp3 = fmap snd . pExp3_internal

pExp4 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp4 = fmap snd . pExp4_internal

pExp5 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp5 = fmap snd . pExp5_internal

pExp6 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp6 = fmap snd . pExp6_internal

pExp :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp = fmap snd . pExp_internal

pExp10 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp10 = fmap snd . pExp10_internal

pExp11 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp11 = fmap snd . pExp11_internal

pType1 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType1 = fmap snd . pType1_internal

pType2 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType2 = fmap snd . pType2_internal

pType3 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType3 = fmap snd . pType3_internal

pType :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType = fmap snd . pType_internal

pCtxVar :: [Token] -> Err Language.STLC.Syntax.Abs.CtxVar
pCtxVar = fmap snd . pCtxVar_internal

pListCtxVar :: [Token] -> Err [Language.STLC.Syntax.Abs.CtxVar]
pListCtxVar = fmap snd . pListCtxVar_internal

pCtx :: [Token] -> Err Language.STLC.Syntax.Abs.Ctx
pCtx = fmap snd . pCtx_internal

pExpUnderCtx :: [Token] -> Err Language.STLC.Syntax.Abs.ExpUnderCtx
pExpUnderCtx = fmap snd . pExpUnderCtx_internal
}

