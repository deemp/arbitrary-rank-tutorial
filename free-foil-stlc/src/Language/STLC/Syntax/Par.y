-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.STLC.Syntax.Par
  ( happyError
  , myLexer
  , pProgram
  , pImportItem
  , pImportItemName
  , pListImportItemName
  , pLocation
  , pStatement
  , pExportItem
  , pListExportItem
  , pListStatement
  , pSynthResult
  , pExp1
  , pExp2
  , pExp3
  , pExp4
  , pExp5
  , pExp6
  , pExp
  , pAccessor
  , pListAccessor
  , pType1
  , pType2
  , pType
  , pCtxVar
  , pListCtxVar
  , pCtx
  , pExpUnderCtx
  ) where

import Prelude

import qualified Language.STLC.Syntax.Abs
import Language.STLC.Syntax.Lex

}

%name pProgram_internal Program
%name pImportItem_internal ImportItem
%name pImportItemName_internal ImportItemName
%name pListImportItemName_internal ListImportItemName
%name pLocation_internal Location
%name pStatement_internal Statement
%name pExportItem_internal ExportItem
%name pListExportItem_internal ListExportItem
%name pListStatement_internal ListStatement
%name pSynthResult_internal SynthResult
%name pExp1_internal Exp1
%name pExp2_internal Exp2
%name pExp3_internal Exp3
%name pExp4_internal Exp4
%name pExp5_internal Exp5
%name pExp6_internal Exp6
%name pExp_internal Exp
%name pAccessor_internal Accessor
%name pListAccessor_internal ListAccessor
%name pType1_internal Type1
%name pType2_internal Type2
%name pType_internal Type
%name pCtxVar_internal CtxVar
%name pListCtxVar_internal ListCtxVar
%name pCtx_internal Ctx
%name pExpUnderCtx_internal ExpUnderCtx
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)         }
  '#'          { PT _ (TS _ 2)         }
  '#typecheck' { PT _ (TS _ 3)         }
  '#typesynth' { PT _ (TS _ 4)         }
  '('          { PT _ (TS _ 5)         }
  ')'          { PT _ (TS _ 6)         }
  '*'          { PT _ (TS _ 7)         }
  '+'          { PT _ (TS _ 8)         }
  ','          { PT _ (TS _ 9)         }
  '->'         { PT _ (TS _ 10)        }
  '.'          { PT _ (TS _ 11)        }
  ':'          { PT _ (TS _ 12)        }
  ';'          { PT _ (TS _ 13)        }
  '<='         { PT _ (TS _ 14)        }
  '='          { PT _ (TS _ 15)        }
  '=>'         { PT _ (TS _ 16)        }
  '?'          { PT _ (TS _ 17)        }
  'Int'        { PT _ (TS _ 18)        }
  '\\'         { PT _ (TS _ 19)        }
  'as'         { PT _ (TS _ 20)        }
  'export'     { PT _ (TS _ 21)        }
  'from'       { PT _ (TS _ 22)        }
  'import'     { PT _ (TS _ 23)        }
  'module'     { PT _ (TS _ 24)        }
  'where'      { PT _ (TS _ 25)        }
  '{'          { PT _ (TS _ 26)        }
  '|-'         { PT _ (TS _ 27)        }
  '}'          { PT _ (TS _ 28)        }
  L_integ      { PT _ (TI _)           }
  L_quoted     { PT _ (TL _)           }
  L_Var        { PT _ (T_Var _)        }
  L_ModuleName { PT _ (T_ModuleName _) }

%%

Integer :: { (Language.STLC.Syntax.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Language.STLC.Syntax.Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Var :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Var) }
Var  : L_Var { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.Var (tokenText $1)) }

ModuleName :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ModuleName) }
ModuleName  : L_ModuleName { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ModuleName (tokenText $1)) }

Program :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Program) }
Program
  : ListStatement { (fst $1, Language.STLC.Syntax.Abs.Program (fst $1) (snd $1)) }

ImportItem :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ImportItem) }
ImportItem
  : '*' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ImportItemGlob (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }
  | '*' 'as' ModuleName { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ImportItemGlobAs (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | '{' ListImportItemName '}' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ImportItemNames (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ImportItemName :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ImportItemName) }
ImportItemName
  : ModuleName { (fst $1, Language.STLC.Syntax.Abs.ImportItemNameModule (fst $1) (snd $1)) }
  | Var { (fst $1, Language.STLC.Syntax.Abs.ImportItemNameVar (fst $1) (snd $1)) }

ListImportItemName :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.ImportItemName]) }
ListImportItemName
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | ImportItemName { (fst $1, (:[]) (snd $1)) }
  | ImportItemName ',' ListImportItemName { (fst $1, (:) (snd $1) (snd $3)) }

Location :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Location) }
Location
  : ModuleName { (fst $1, Language.STLC.Syntax.Abs.LocationLocal (fst $1) (snd $1)) }
  | String { (fst $1, Language.STLC.Syntax.Abs.LocationPath (fst $1) (snd $1)) }

Statement :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Statement) }
Statement
  : 'module' ModuleName 'where' '{' ListStatement '}' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementModule (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'import' ImportItem 'from' Location { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementImportLocal (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Var ':' Type { (fst $1, Language.STLC.Syntax.Abs.StatementFunSig (fst $1) (snd $1) (snd $3)) }
  | Var '=' Exp { (fst $1, Language.STLC.Syntax.Abs.StatementFun (fst $1) (snd $1) (snd $3)) }
  | Var '=' Exp 'where' '{' ListStatement '}' { (fst $1, Language.STLC.Syntax.Abs.StatementFunWhere (fst $1) (snd $1) (snd $3) (snd $6)) }
  | 'export' ListExportItem { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementExport (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '#typecheck' ExpUnderCtx '<=' Type { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementCommandTypeCheck (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '#typesynth' ExpUnderCtx '=>' SynthResult { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.StatementCommandTypeSynth (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ExportItem :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ExportItem) }
ExportItem
  : ModuleName { (fst $1, Language.STLC.Syntax.Abs.ExportItemModuleName (fst $1) (snd $1)) }
  | Var { (fst $1, Language.STLC.Syntax.Abs.ExportItemVar (fst $1) (snd $1)) }

ListExportItem :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.ExportItem]) }
ListExportItem
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | ExportItem { (fst $1, (:[]) (snd $1)) }
  | ExportItem ',' ListExportItem { (fst $1, (:) (snd $1) (snd $3)) }

ListStatement :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.Statement]) }
ListStatement
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | Statement ';' ListStatement { (fst $1, (:) (snd $1) (snd $3)) }

SynthResult :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.SynthResult) }
SynthResult
  : '!' Type { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.SynthResultType (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '?' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.SynthResultUnknown (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }

Exp1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp1
  : '(' Exp ')' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpApp (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp2
  : '\\' Var '.' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpAbs (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Exp3 { (fst $1, (snd $1)) }

Exp3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp3
  : Exp3 '+' Exp4 { (fst $1, Language.STLC.Syntax.Abs.ExpPlus (fst $1) (snd $1) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp4 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp4
  : Var { (fst $1, Language.STLC.Syntax.Abs.ExpVar (fst $1) (snd $1)) }
  | Exp5 { (fst $1, (snd $1)) }

Exp5 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp5
  : Integer { (fst $1, Language.STLC.Syntax.Abs.ExpNumber (fst $1) (snd $1)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp6 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp6
  : '#' ListAccessor { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpAccessor (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp : Exp1 { (fst $1, (snd $1)) }

Accessor :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Accessor) }
Accessor
  : ModuleName { (fst $1, Language.STLC.Syntax.Abs.AccessorModuleName (fst $1) (snd $1)) }
  | Var { (fst $1, Language.STLC.Syntax.Abs.AccessorVar (fst $1) (snd $1)) }

ListAccessor :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.Accessor]) }
ListAccessor
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | Accessor { (fst $1, (:[]) (snd $1)) }
  | Accessor '.' ListAccessor { (fst $1, (:) (snd $1) (snd $3)) }

Type1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type1
  : 'Int' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TypeUnit (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }
  | Type2 { (fst $1, (snd $1)) }

Type2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type2
  : Type '->' Type { (fst $1, Language.STLC.Syntax.Abs.TypeFunc (fst $1) (snd $1) (snd $3)) }
  | '(' Type ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type : Type1 { (fst $1, (snd $1)) }

CtxVar :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.CtxVar) }
CtxVar
  : Var ':' Type { (fst $1, Language.STLC.Syntax.Abs.CtxVar (fst $1) (snd $1) (snd $3)) }

ListCtxVar :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.CtxVar]) }
ListCtxVar
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | CtxVar { (fst $1, (:[]) (snd $1)) }
  | CtxVar ',' ListCtxVar { (fst $1, (:) (snd $1) (snd $3)) }

Ctx :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Ctx) }
Ctx
  : ListCtxVar { (fst $1, Language.STLC.Syntax.Abs.Ctx (fst $1) (snd $1)) }

ExpUnderCtx :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ExpUnderCtx) }
ExpUnderCtx
  : Ctx '|-' Exp { (fst $1, Language.STLC.Syntax.Abs.ExpUnderCtx (fst $1) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Language.STLC.Syntax.Abs.Program
pProgram = fmap snd . pProgram_internal

pImportItem :: [Token] -> Err Language.STLC.Syntax.Abs.ImportItem
pImportItem = fmap snd . pImportItem_internal

pImportItemName :: [Token] -> Err Language.STLC.Syntax.Abs.ImportItemName
pImportItemName = fmap snd . pImportItemName_internal

pListImportItemName :: [Token] -> Err [Language.STLC.Syntax.Abs.ImportItemName]
pListImportItemName = fmap snd . pListImportItemName_internal

pLocation :: [Token] -> Err Language.STLC.Syntax.Abs.Location
pLocation = fmap snd . pLocation_internal

pStatement :: [Token] -> Err Language.STLC.Syntax.Abs.Statement
pStatement = fmap snd . pStatement_internal

pExportItem :: [Token] -> Err Language.STLC.Syntax.Abs.ExportItem
pExportItem = fmap snd . pExportItem_internal

pListExportItem :: [Token] -> Err [Language.STLC.Syntax.Abs.ExportItem]
pListExportItem = fmap snd . pListExportItem_internal

pListStatement :: [Token] -> Err [Language.STLC.Syntax.Abs.Statement]
pListStatement = fmap snd . pListStatement_internal

pSynthResult :: [Token] -> Err Language.STLC.Syntax.Abs.SynthResult
pSynthResult = fmap snd . pSynthResult_internal

pExp1 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp1 = fmap snd . pExp1_internal

pExp2 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp2 = fmap snd . pExp2_internal

pExp3 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp3 = fmap snd . pExp3_internal

pExp4 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp4 = fmap snd . pExp4_internal

pExp5 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp5 = fmap snd . pExp5_internal

pExp6 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp6 = fmap snd . pExp6_internal

pExp :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp = fmap snd . pExp_internal

pAccessor :: [Token] -> Err Language.STLC.Syntax.Abs.Accessor
pAccessor = fmap snd . pAccessor_internal

pListAccessor :: [Token] -> Err [Language.STLC.Syntax.Abs.Accessor]
pListAccessor = fmap snd . pListAccessor_internal

pType1 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType1 = fmap snd . pType1_internal

pType2 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType2 = fmap snd . pType2_internal

pType :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType = fmap snd . pType_internal

pCtxVar :: [Token] -> Err Language.STLC.Syntax.Abs.CtxVar
pCtxVar = fmap snd . pCtxVar_internal

pListCtxVar :: [Token] -> Err [Language.STLC.Syntax.Abs.CtxVar]
pListCtxVar = fmap snd . pListCtxVar_internal

pCtx :: [Token] -> Err Language.STLC.Syntax.Abs.Ctx
pCtx = fmap snd . pCtx_internal

pExpUnderCtx :: [Token] -> Err Language.STLC.Syntax.Abs.ExpUnderCtx
pExpUnderCtx = fmap snd . pExpUnderCtx_internal
}

