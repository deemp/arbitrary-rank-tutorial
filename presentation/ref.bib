
@inproceedings{maclaurin_foil_2022,
  location   = {Copenhagen Denmark},
  title      = {The Foil: Capture-Avoiding Substitution With No Sharp Edges},
  isbn       = {978-1-4503-9831-2},
  url        = {https://dl.acm.org/doi/10.1145/3587216.3587224},
  doi        = {10.1145/3587216.3587224},
  shorttitle = {The Foil},
  abstract   = {Correctly manipulating program terms in a compiler is surprisingly difficult because of the need to avoid name capture. The rapier from Peyton Jones and Marlow [9] is a cutting-edge technique for fast, stateless capture-avoiding substitution for expressions represented with explicit names. It is, however, a sharp tool—its invariants are tricky and need to be maintained throughout the whole compiler that uses it. We describe the foil, an elaboration of the rapier that uses Haskell’s type system to enforce the rapier’s invariants statically, preventing a class of hard-to-find bugs, but without adding any run-time overheads.},
  eventtitle = {{IFL} 2022: Symposium on Implementation and Application of Functional Languages},
  pages      = {1--10},
  booktitle  = {Proceedings of the 34th Symposium on Implementation and Application of Functional Languages},
  publisher  = {{ACM}},
  author     = {Maclaurin, Dougal and Radul, Alexey and Paszke, Adam},
  urldate    = {2024-11-11},
  date       = {2022-08-31},
  langid     = {english}
}

@unpublished{kudasov_free_2024,
  title      = {Free Foil: Generating Efficient and Scope-Safe Abstract Syntax},
  url        = {http://arxiv.org/abs/2405.16384},
  doi        = {10.48550/arXiv.2405.16384},
  shorttitle = {Free Foil},
  abstract   = {Handling bound identifiers correctly and efficiently is critical in implementations of compilers, proof assistants, and theorem provers. When choosing a representation for abstract syntax with binders, implementors face a trade-off between type safety with intrinsic scoping, efficiency, and generality. The "foil" by Maclaurin, Radul, and Paszke combines an efficient implementation of the Barendregt convention with intrinsic scoping through advanced type system features in Haskell, such as rank-2 polymorphism and generalized algebraic data types. Free scoped monads of Kudasov, on the other hand, combine intrinsic scoping with de Bruijn indices as nested data types with Sweirstra's data types {\textbackslash}`a la carte approach to allow generic implementation of algorithms such as higher-order unification. In this paper, we suggest two approaches of making the foil more affordable. First, we marry free scoped monads with the foil, allowing to generate efficient, type-safe, and generic abstract syntax representation with binders for any language given its second-order signature. Second, we provide Template Haskell functions that allow generating the scope-safe representation from a na{\textbackslash}"ive one. The latter approach enables us to use existing tools like {BNF} Converter to very quickly prototype complete implementation of languages, including parsing, pretty-printing, and efficient intrinsically scoped abstract syntax. We demonstrate both approaches using \${\textbackslash}lambda{\textbackslash}Pi\$ with pairs and patterns as our example object language. Finally, we provide benchmarks comparing our implementation against the foil, free scoped monads with nested de Bruijn indices, and some traditional implementations.},
  number     = {{arXiv}:2405.16384},
  publisher  = {{arXiv}},
  author     = {Kudasov, Nikolai and Shakirova, Renata and Shalagin, Egor and Tyulebaeva, Karina},
  urldate    = {2024-11-11},
  date       = {2024-05-26},
  eprinttype = {arxiv},
  eprint     = {2405.16384},
  keywords   = {Computer Science - Programming Languages},
  note       = {Available at \url{https://arxiv.org/pdf/2405.16384}}
}

@misc{noauthor_language_server_protocol_2024,
  title     = {Language Server Protocol},
  rights    = {Creative Commons Attribution-{ShareAlike} License},
  url       = {https://en.wikipedia.org/w/index.php?title=Language_Server_Protocol&oldid=1236113985},
  abstract  = {The Language Server Protocol ({LSP}) is an open, {JSON}-{RPC}-based protocol for use between source code editors or integrated development environments ({IDEs}) and servers that provide "language intelligence tools": programming language-specific features like code completion, syntax highlighting and marking of warnings and errors, as well as refactoring routines. The goal of the protocol is to allow programming language support to be implemented and distributed independently of any given editor or {IDE}. In the early 2020s, {LSP} quickly became a "norm" for language intelligence tools providers.},
  booktitle = {Wikipedia},
  urldate   = {2024-11-11},
  date      = {2024-07-22},
  langid    = {english},
  note      = {Available at \url{https://en.wikipedia.org/w/index.php?title=Language_Server_Protocol&oldid=1236113985}}
}

@misc{noauthor_langium_nodate,
  title      = {Langium},
  url        = {https://langium.org},
  abstract   = {Langium is an open source language engineering tool with first-class support for the Language Server Protocol, written in {TypeScript} and running in Node.js.},
  titleaddon = {Langium},
  urldate    = {2024-11-11},
  langid     = {english},
  note       = {Available at \url{https://langium.org}}
}


@misc{noauthor_neomuttlsp-tree-sitter_2024,
  title     = {neomutt/lsp-tree-sitter},
  rights    = {{GPL}-3.0},
  url       = {https://github.com/neomutt/lsp-tree-sitter},
  abstract  = {A library to create language servers.},
  publisher = {{NeoMutt}},
  urldate   = {2024-11-11},
  date      = {2024-10-24},
  note      = {Available at \url{https://github.com/neomutt/lsp-tree-sitter}},
  keywords  = {json-schema, language-server-protocol, tree-sitter}
}

@misc{hackage_formal_languages,
  title = {Hackage packages in the "Formal Languages" category},
  note  = {Available at \url{https://hackage.haskell.org/packages/#cat:Formal%20Languages}}
}

@misc{hackage_language,
  title = {Hackage packages in the "Language" category},
  note  = {Available at \url{https://hackage..haskell.org/packages/#cat:Language}}
}

@misc{github_haskell_programming_language,
  title = {Search results on github.com for "programming language language:haskell"},
  note  = {Available at \url{https://github.com/search?q=programming+language+language%3Ahaskell&type=repositories}}
}

@misc{github_lsp_module,
  title = {Search results on github.com for "Language.LSP.Server language:haskell"},
  note  = {Available at \url{https://github.com/search?q=Language.LSP.Server+language%3Ahaskell&type=code}}
}

@misc{hackage_free_foil,
  title = {free-foil package on Hackage},
  note  = {Available at \url{https://hackage.haskell.org/package/free-foil}}
}

@misc{fiore_formal_2022,
  title      = {Formal Metatheory of Second-Order Abstract Syntax},
  url        = {http://arxiv.org/abs/2201.03504},
  doi        = {10.48550/arXiv.2201.03504},
  abstract   = {Despite extensive research both on the theoretical and practical fronts, formalising, reasoning about, and implementing languages with variable binding is still a daunting endeavour - repetitive boilerplate and the overly complicated metatheory of capture-avoiding substitution often get in the way of progressing on to the actually interesting properties of a language. Existing developments offer some relief, however at the expense of inconvenient and error-prone term encodings and lack of formal foundations. We present a mathematically-inspired language-formalisation framework implemented in Agda. The system translates the description of a syntax signature with variable-binding operators into an intrinsically-encoded, inductive data type equipped with syntactic operations such as weakening and substitution, along with their correctness properties. The generated metatheory further incorporates metavariables and their associated operation of metasubstitution, which enables second-order equational/rewriting reasoning. The underlying mathematical foundation of the framework - initial algebra semantics - derives compositional interpretations of languages into their models satisfying the semantic substitution lemma by construction.},
  number     = {{arXiv}:2201.03504},
  publisher  = {{arXiv}},
  author     = {Fiore, Marcelo and Szamozvancev, Dmitrij},
  urldate    = {2024-11-12},
  date       = {2022-01-10},
  eprinttype = {arxiv},
  eprint     = {2201.03504},
  keywords   = {Computer Science - Discrete Mathematics, Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
  file       = {Preprint PDF:/home/eyjafjallajokull/Zotero/storage/L3Y3IZ8A/Fiore and Szamozvancev - 2022 - Formal Metatheory of Second-Order Abstract Syntax.pdf:application/pdf;Snapshot:/home/eyjafjallajokull/Zotero/storage/SCQW5VA2/2201.html:text/html}
}

@misc{hackage_bnfc,
  title = {BNFC package on Hackage},
  note  = {Available at \url{https://hackage.haskell.org/package/BNFC}}
}

@misc{hackage_lsp,
  title = {lsp package on Hackage},
  note  = {Available at \url{https://hackage.haskell.org/package/lsp}}
}

@misc{wiki_stlc,
  title     = {Simply typed lambda calculus},
  rights    = {Creative Commons Attribution-{ShareAlike} License},
  url       = {https://en.wikipedia.org/w/index.php?title=Simply_typed_lambda_calculus&oldid=1252118159},
  booktitle = {Wikipedia},
  urldate   = {2024-11-12},
  date      = {2024-10-19},
  langid    = {english},
  note      = {Available at \url{https://en.wikipedia.org/w/index.php?title=Simply_typed_lambda_calculus&oldid=1252118159}},
  file      = {Snapshot:/home/eyjafjallajokull/Zotero/storage/FBNN68CF/Simply_typed_lambda_calculus.html:text/html}
}


@online{noauthor_fizrukstella_nodate,
  title      = {fizruk/stella: Structurally Typed Extensible Language for Learning {ACCPA}},
  url        = {https://github.com/fizruk/stella},
  shorttitle = {fizruk/stella},
  abstract   = {Structurally Typed Extensible Language for Learning {ACCPA} - fizruk/stella},
  titleaddon = {{GitHub}},
  urldate    = {2024-11-12},
  langid     = {english},
  note       = {Available at \url{https://github.com/fizruk/stella}}
}


@misc{lsp_implementations,
  title = {LSP implementations},
  note  = {Available at \url{https://microsoft.github.io/language-server-protocol/implementors/servers/}}
}


@misc{github_rzk_lang_rzk,
	title = {rzk-lang/rzk: An experimental proof assistant based on a type theory for synthetic ∞-categories.},
	url = {https://github.com/rzk-lang/rzk},
	urldate = {2024-11-12},
	note = {Available at \url{https://github.com/rzk-lang/rzk}}
}

@misc{github_query_driven_free_foil,
	title = { A repository for the MS thesis Query-Driven Language Server Architecture using Second-Order Abstract Syntax},
	urldate = {2024-11-12},
	note = {Available at \url{https://github.com/deemp/query-driven-free-foil/}}
}


@misc{dunfield_bidirectional_2020,
	title = {Bidirectional Typing},
	url = {http://arxiv.org/abs/1908.05839},
	doi = {10.48550/arXiv.1908.05839},
	abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations.},
	number = {{arXiv}:1908.05839},
	publisher = {{arXiv}},
	author = {Dunfield, Jana and Krishnaswami, Neel},
	urldate = {2024-11-12},
	date = {2020-11-14},
	eprinttype = {arxiv},
	eprint = {1908.05839},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
	file = {Preprint PDF:/home/eyjafjallajokull/Zotero/storage/D2UY3CG6/Dunfield and Krishnaswami - 2020 - Bidirectional Typing.pdf:application/pdf;Snapshot:/home/eyjafjallajokull/Zotero/storage/GMLTALDD/1908.html:text/html},
}
