
@inproceedings{maclaurin_foil_2022,
	location = {Copenhagen Denmark},
	title = {The Foil: Capture-Avoiding Substitution With No Sharp Edges},
	isbn = {978-1-4503-9831-2},
	url = {https://dl.acm.org/doi/10.1145/3587216.3587224},
	doi = {10.1145/3587216.3587224},
	shorttitle = {The Foil},
	abstract = {Correctly manipulating program terms in a compiler is surprisingly difficult because of the need to avoid name capture. The rapier from Peyton Jones and Marlow [9] is a cutting-edge technique for fast, stateless capture-avoiding substitution for expressions represented with explicit names. It is, however, a sharp tool—its invariants are tricky and need to be maintained throughout the whole compiler that uses it. We describe the foil, an elaboration of the rapier that uses Haskell’s type system to enforce the rapier’s invariants statically, preventing a class of hard-to-find bugs, but without adding any run-time overheads.},
	eventtitle = {{IFL} 2022: Symposium on Implementation and Application of Functional Languages},
	pages = {1--10},
	booktitle = {Proceedings of the 34th Symposium on Implementation and Application of Functional Languages},
	publisher = {{ACM}},
	author = {Maclaurin, Dougal and Radul, Alexey and Paszke, Adam},
	urldate = {2024-11-11},
	date = {2022-08-31},
	langid = {english},
}

@misc{kudasov_free_2024,
	title = {Free Foil: Generating Efficient and Scope-Safe Abstract Syntax},
	url = {http://arxiv.org/abs/2405.16384},
	doi = {10.48550/arXiv.2405.16384},
	shorttitle = {Free Foil},
	abstract = {Handling bound identifiers correctly and efficiently is critical in implementations of compilers, proof assistants, and theorem provers. When choosing a representation for abstract syntax with binders, implementors face a trade-off between type safety with intrinsic scoping, efficiency, and generality. The "foil" by Maclaurin, Radul, and Paszke combines an efficient implementation of the Barendregt convention with intrinsic scoping through advanced type system features in Haskell, such as rank-2 polymorphism and generalized algebraic data types. Free scoped monads of Kudasov, on the other hand, combine intrinsic scoping with de Bruijn indices as nested data types with Sweirstra's data types {\textbackslash}`a la carte approach to allow generic implementation of algorithms such as higher-order unification. In this paper, we suggest two approaches of making the foil more affordable. First, we marry free scoped monads with the foil, allowing to generate efficient, type-safe, and generic abstract syntax representation with binders for any language given its second-order signature. Second, we provide Template Haskell functions that allow generating the scope-safe representation from a na{\textbackslash}"ive one. The latter approach enables us to use existing tools like {BNF} Converter to very quickly prototype complete implementation of languages, including parsing, pretty-printing, and efficient intrinsically scoped abstract syntax. We demonstrate both approaches using \${\textbackslash}lambda{\textbackslash}Pi\$ with pairs and patterns as our example object language. Finally, we provide benchmarks comparing our implementation against the foil, free scoped monads with nested de Bruijn indices, and some traditional implementations.},
	number = {{arXiv}:2405.16384},
	publisher = {{arXiv}},
	author = {Kudasov, Nikolai and Shakirova, Renata and Shalagin, Egor and Tyulebaeva, Karina},
	urldate = {2024-11-11},
	date = {2024-05-26},
	eprinttype = {arxiv},
	eprint = {2405.16384},
	keywords = {Computer Science - Programming Languages},
}

@misc{noauthor_language_server_protocol_2024,
	title = {Language Server Protocol},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Language_Server_Protocol&oldid=1236113985},
	abstract = {The Language Server Protocol ({LSP}) is an open, {JSON}-{RPC}-based protocol for use between source code editors or integrated development environments ({IDEs}) and servers that provide "language intelligence tools": programming language-specific features like code completion, syntax highlighting and marking of warnings and errors, as well as refactoring routines. The goal of the protocol is to allow programming language support to be implemented and distributed independently of any given editor or {IDE}. In the early 2020s, {LSP} quickly became a "norm" for language intelligence tools providers.},
	booktitle = {Wikipedia},
	urldate = {2024-11-11},
	date = {2024-07-22},
	langid = {english},
	note = {Page Version {ID}: 1236113985},
}

@misc{noauthor_langium_nodate,
	title = {Langium},
	url = {https://langium.org},
	abstract = {Langium is an open source language engineering tool with first-class support for the Language Server Protocol, written in {TypeScript} and running in Node.js.},
	titleaddon = {Langium},
	urldate = {2024-11-11},
	langid = {english},
}


@misc{noauthor_neomuttlsp-tree-sitter_2024,
	title = {neomutt/lsp-tree-sitter},
	rights = {{GPL}-3.0},
	url = {https://github.com/neomutt/lsp-tree-sitter},
	abstract = {A library to create language servers.},
	publisher = {{NeoMutt}},
	urldate = {2024-11-11},
	date = {2024-10-24},
	note = {original-date: 2023-06-19T15:04:15Z},
	keywords = {json-schema, language-server-protocol, tree-sitter},
}
