
% --- Пользовательские команды ---
\newcommand{\Arralac}{\texttt{Arralac}}

\textbf{Общая характеристика работы}

Настоящая диссертация посвящена проектированию и реализации \Arralac — небольшого функционального языка программирования и сопутствующего ему компилятора. Основная цель проекта — преодолеть педагогический разрыв между сложной академической теорией систем типов и практикой реализации современных компиляторов. Работа не претендует на научную новизну, а фокусируется на применении известных, но передовых инженерных подходов для создания прозрачного, модульного и интерактивного инструмента, предназначенного для изучения внутреннего устройства компилятора.

Центральный тезис работы заключается в том, что сфокусированная, современная и интерактивная реализация, сознательно отходящая от старых алгоритмических моделей, может служить более эффективным средством обучения, чем изолированное изучение фундаментальных научных статей или исходного кода промышленных компиляторов.

Работа представляет собой полный цикл разработки: от теоретического обоснования и проектирования архитектуры до реализации, тестирования и анализа полученной системы. Особое внимание уделяется двум ключевым аспектам современной инженерии компиляторов: архитектуре вывода типов на основе ограничений (constraint-based) и представлению АСД с помощью паттерна «Растущие деревья» (Trees That Grow).

\newpage

\section*{Актуальность темы}

Продвинутые системы типов являются краеугольным камнем современного функционального программирования. Одной из таких мощных возможностей является \textbf{полиморфизм произвольных рангов} (arbitrary-rank polymorphism), который позволяет функциям принимать в качестве аргументов другие полиморфные функции. Эта возможность лежит в основе реализации таких продвинутых языковых средств, как GADT, программирование на уровне типов и сложные формы обобщённого программирования.

Теоретические основы для реализации этой функции в практическом компиляторе были заложены в основополагающей статье Пейтона Джонса и др. «Практический вывод типов для полиморфизма произвольных рангов» \cite{jones-practical-2007}. Самой известной реализацией этих идей является компилятор языка Haskell — Glasgow Haskell Compiler (GHC) \cite{ghc-site-2025}. Для многих разработчиков, включая автора данной работы, внутреннее устройство GHC представляет собой вершину компиляторных технологий — «достаточно развитую технологию», которая может казаться магией.

Несмотря на наличие как фундаментальной теории, так и промышленной реализации, существует значительный педагогический разрыв. Начинающие разработчики языков и студенты сталкиваются с крутой кривой обучения при попытке понять, как элегантная теория полиморфизма произвольных рангов преобразуется в практический код. Этот разрыв обусловлен несколькими факторами:
\begin{itemize}
    \item \textbf{Академическая литература}, включая \cite{jones-practical-2007}, представляет теоретически плотную систему, построенную на сложном взаимодействии \textbf{субсумпции} (subsumption), \textbf{глубокой сколемизации} (deep skolemization) и \textbf{двунаправленной проверки типов} (bidirectional checking). Хотя система формально корректна \cite{practical-type-inference-proofs}, описание алгоритма \textbf{«жадного» объединения} (eager unification) в статье опускает множество практических инженерных деталей.
    \item \textbf{Исходный код GHC}, будучи бесценным ресурсом, представляет собой огромную, высокооптимизированную промышленную систему. Его современная архитектура вывода типов, \textbf{основанная на ограничениях} (constraint-based), является значительной эволюцией по сравнению с «жадной» моделью, описанной в основополагающих статьях. Это затрудняет прослеживание связи между теорией и реализацией для новичка. Современные аналоги, такие как MicroHs \cite{augustsson-microhs-2024, augustss-microhs-2025}, также являются крупными проектами.
    \item \textbf{Существующие учебные компиляторы} для Haskell, такие как Hugs \cite{hugs-haskell}, устарели или не включают эти современные архитектурные паттерны, оставляя студентов без моста от базовых принципов к современному состоянию дел.
\end{itemize}

Возникает очевидная потребность в ресурсе, который преодолевает этот разрыв, — «промежуточном звене», более конкретном, чем статья, но более сфокусированном и доступном, чем полноценный промышленный компилятор.

\newpage

\section*{Цели и задачи исследования}
Основной \textbf{целью} данной работы является создание дидактического компилятора \Arralac, который служит учебным пособием по реализации полиморфизма произвольных рангов с использованием современных архитектурных практик.

Для достижения этой цели были поставлены следующие \textbf{задачи}:
\begin{enumerate}
    \item Реализовать ключевые алгоритмы двунаправленной системы вывода типов, включая субсумпцию и глубокую сколемизацию, в ясной и модульной манере, пригодной для образовательных целей.
    \item Продемонстрировать, что модель вывода типов, основанная на ограничениях, служит более понятным педагогическим инструментом для объяснения вывода типов, чем модель «жадного» объединения, представленная в фундаментальной литературе.
    \item Использовать протокол языкового сервера (LSP) для создания интерактивной среды разработки, которая делает поведение и результаты конвейера вывода типов языка прозрачными и исследуемыми.
    \item Создать общедоступный репозиторий с исходным кодом \cite{deemp-arbitrary-rank-tutorial} в качестве ресурса для сообщества для обучения и экспериментов.
\end{enumerate}

\section*{Структура работы}

Диссертация состоит из введения, четырёх глав, заключения и списка литературы.

\begin{itemize}
    \item \textbf{Во введении} обосновывается актуальность темы, определяется проблема педагогического разрыва, формулируются цели и задачи исследования, а также описывается вклад работы.
    
    \item \textbf{В первой главе, «Обзор литературы»,} представлены теоретические основы работы. Прослеживается эволюция полиморфных систем типов от компромисса Хиндли-Милнера до практического двунаправленного подхода для типов произвольных рангов.
    
    \item \textbf{Во второй главе, «Проектирование и методология»,} подробно описывается архитектура и реализация языка \Arralac. Рассматривается полный конвейер компиляции с особым акцентом на архитектуре тайпчекера на основе ограничений и представлении АСД «Растущие деревья».
    
    \item \textbf{В третьей главе, «Реализация и результаты»,} демонстрируется практическая реализация системы. Приводятся примеры работы компилятора на корректных и некорректных программах, а также работа интерактивных инструментов (LSP).
    
    \item \textbf{В четвёртой главе, «Анализ и обсуждение»,} проводится критический анализ полученной системы в соответствии с её педагогическими целями, обсуждаются компромиссы архитектурных решений и извлечённые уроки.
    
    \item \textbf{В заключении} подводятся итоги работы, пересматривается центральный тезис в свете полученных результатов и намечаются возможные направления для будущих исследований.
\end{itemize}

\newpage

\section*{Краткое содержание работы}

\subsection*{Глава 1. Обзор литературы}

В этой главе закладывается теоретический фундамент работы. Обзор начинается с основ типизированных функциональных языков, таких как \textbf{лямбда-исчисление} и его просто типизированный вариант (STLC) \cite{Pierce-SF2}. Подчёркивается, что строгость и безопасность STLC достигаются ценой выразительности из-за его \textbf{мономорфизма}, что создаёт потребность в полиморфных системах.

Далее рассматривается \textbf{Система F} \cite{girard-system-f} как теоретический идеал полиморфизма, вводящий понятия \textbf{параметрического полиморфизма} и типов вида \texttt{forall a. a -> a}. Вводится ключевое различие между предикативным и импредикативным полиморфизмом и объясняется, почему полный вывод типов для импредикативных систем неразрешим \cite{wells-typability-1999, serrano-quick-2020}. Это обосновывает выбор предикативного фрагмента для \Arralac, следуя прагматичной традиции GHC \cite{jones-practical-2007}.

Центральное место в обзоре занимает \textbf{система типов Дамаса-Хиндли-Милнера (HM)} \cite{damas-milner} как практический компромисс. Ограничение системы HM \textbf{типами ранга 1} (кванторы \texttt{forall} только на внешнем уровне) делает вывод типов разрешимым и эффективным (Алгоритм W), но создаёт «пробел N-го ранга» (Rank-N gap), не позволяя передавать полиморфные функции в качестве аргументов.

Решение этой проблемы представлено в работе Пейтона Джонса и др. \cite{jones-practical-2007}, которая является прямой теоретической основой данной диссертации. Их \textbf{двунаправленный алгоритм вывода типов} с режимами \textbf{вывода} (inference) и \textbf{проверки} (checking) позволяет обрабатывать типы высших рангов, полагаясь на аннотации программиста для переключения в режим проверки. Ключевые механизмы этого алгоритма — \textbf{субсумпция} и \textbf{глубокая сколемизация} — формируют ядро, реализованное в \Arralac.

Глава завершается кратким обзором современного ландшафта, упоминающим более формальные двунаправленные системы \cite{dunfield-complete-2013, dunfield-bidirectional-2020} и альтернативные подходы, основанные на подтипизации \cite{parreaux-when-2024}, что дополнительно обосновывает выбор системы из \cite{jones-practical-2007} как наиболее подходящей для педагогического проекта.

\newpage

\subsection*{Глава 2. Проектирование и методология}

Эта глава подробно описывает архитектуру компилятора \Arralac.

\textbf{Конвейер компиляции.} Система построена как многостадийный конвейер, что способствует модульности и разделению ответственности. Этапы включают:
\begin{itemize}
    \item Чтение и парсинг (с помощью BNFC \cite{bnfc-site-2025})
    \item Переименование (разрешение имён и $\alpha$-преобразование)
    \item Проверка типов (генерация ограничений)
    \item Решение (решение ограничений)
    \item Зонкинг (подстановка выведенных типов в АСД)
    \item Преобразование в ядро (Core)
    \item Вычисление
\end{itemize}

\textbf{Проектирование АСД.} Ключевым архитектурным решением является использование паттерна \textbf{«Растущие деревья» (Trees That Grow, TTG)} \cite{trees-that-grow-2016} для представления абстрактного синтаксического дерева. В отличие от более простых подходов, TTG позволяет расширять узлы АСД аннотациями, специфичными для каждого прохода компилятора, типобезопасным образом. Это достигается за счёт параметризации типов данных АСД и использования семейств типов (type families) для полей-расширений. Такой подход отражает архитектуру GHC \cite{ghc-gitlab-2025} и является мощным педагогическим инструментом сам по себе.

\textbf{Вывод типов и решение ограничений.} Это ядро диссертации. Вместо «жадного» объединения, описанного в \cite{jones-practical-2007}, \Arralac реализует двухфазную модель, вдохновлённую GHC, которая разделяет \textbf{генерацию ограничений} и их \textbf{решение}.
\begin{enumerate}
    \item \textbf{Генерация ограничений (Typechecker).} На этом этапе тайпчекер обходит АСД и генерирует набор «желаемых» ограничений (\textit{wanted constraints} \cite{wits-type-inference-using-constraints}). Используются два основных типа ограничений:
    \begin{itemize}
        \item \textbf{Равенства (\texttt{EqCt}):} Требуют, чтобы метапеременная была равна определённому типу.
        \item \textbf{Импликации (\texttt{Implication}):} Моделируют области видимости полиморфизма. Они связывают сколемизированные переменные с набором ограничений, которые должны быть решены в их области видимости.
    \end{itemize}
    
    \item \textbf{Решение ограничений (Solver).} Отдельный модуль-решатель итеративно обрабатывает сгенерированные ограничения. Для контроля областей видимости и предотвращения «побега сколемов» (skolem escape) используется техника \textbf{уровней (\texttt{TcLevel})}. Каждой переменной при создании присваивается уровень, и решатель следит, чтобы метапеременная уровня $n$ не объединялась с типом, содержащим переменные более глубокого уровня $m > n$.
\end{enumerate}

Эта архитектура делает систему более модульной и создаёт прочную основу для качественной диагностики ошибок, что является ключевым преимуществом по сравнению с моделью «жадного» объединения.

\textbf{Ограничения.} В работе сознательно принят ряд упрощений: отсутствует обобщение \texttt{let}-связываний (let-generalization) \cite{vytiniotis-outsideinx-2011}, рекурсивные связывания, а также используется простое нетипизированное ядро (Core language) для вычислений. Эти ограничения позволили сфокусироваться на алгоритме вывода типов.

\newpage

\subsection*{Глава 3. Реализация и результаты}

В этой главе описывается конкретная реализация архитектуры на языке Haskell и демонстрируются результаты её работы.

\textbf{Реализация АСД.} Показано, как паттерн TTG реализован с помощью параметризованных типов данных (\texttt{SynTerm x}, \texttt{SynType x}) и семейств типов. Для каждого прохода компилятора (например, \texttt{CompTc} для типизированного АСД) определяются свои экземпляры семейств типов, добавляя в узлы АСД необходимые аннотации, такие как выведенный тип (\texttt{TcAnno}).

\textbf{Реализация конвейера вывода типов.} Подробно описаны ключевые модули:
\begin{itemize}
    \item \textbf{Typechecker} (\texttt{Language.Arralac.Typechecker.TcTerm}): реализует двунаправленный алгоритм и генерирует ограничения. Функция \texttt{pushLevelAndCaptureConstraints} создаёт импликационные ограничения для обработки областей видимости.
    \item \textbf{Solver} (\texttt{Language.Arralac.Solver.Solve}): итеративно решает простой список ограничений-равенств, выполняя проверки на вхождение (occurs check) и проверки уровней для предотвращения побега сколемов.
    \item \textbf{Zonker} (\texttt{Language.Arralac.Zonker.Zn.Zonk}): финальный проход, который заменяет все решённые метапеременные их окончательными типами, создавая «чистое» АСД без изменяемых ссылок.
\end{itemize}

\textbf{Результаты в действии.}
\begin{itemize}
    \item \textbf{Позитивный случай:} Программа, требующая передачи полиморфной функции в качестве аргумента, успешно проходит проверку типов. Вывод компилятора демонстрирует, что типы высших рангов были корректно выведены и применены.
    \item \textbf{Негативный случай:} Программа, специально созданная для провоцирования «побега сколема», корректно отвергается решателем. Выданное сообщение об ошибке точно указывает на нарушение проверки уровней, подтверждая надёжность механизма.
    \item \textbf{Интерактивные инструменты:} Демонстрируется работа Language Server Protocol (LSP). Скриншоты из Visual Studio Code показывают, как пользователь может навести курсор на идентификатор и увидеть его полный выведенный тип, а также получать мгновенные сообщения об ошибках (например, о необъявленной переменной). Это превращает внутренние данные компилятора в полезную обратную связь для пользователя.
\end{itemize}

\textbf{Характеристики кодовой базы.} Анализ с помощью утилиты \texttt{cloc} показывает, что проект состоит из 86 модулей на языке Haskell, что свидетельствует о высокой \textbf{модульности}. Система обработки ошибок, где каждый этап конвейера генерирует свой тип исключения со стеком вызовов, обеспечивает хорошую \textbf{анализируемость}. Использование Nix для сборки гарантирует \textbf{устанавливаемость} и воспроизводимость.

\newpage

\subsection*{Глава 4. Анализ и обсуждение}

Эта глава содержит критический анализ проекта, его архитектурных решений и ограничений.

\textbf{Анализ архитектурных вкладов.} Главным вкладом работы является практическая реализация предложения из \cite[Sec. 9.6]{jones-practical-2007} о переходе к системе на основе ограничений. \Arralac демонстрирует, что такое разделение на генерацию и решение ограничений даёт два ключевых преимущества:
\begin{enumerate}
    \item \textbf{Повышенная модульность:} Логика тайпчекера и решателя полностью разделена, что упрощает их понимание и модификацию по отдельности.
    \item \textbf{Основа для лучшей диагностики ошибок:} Сбор всех ограничений перед решением позволяет в будущем анализировать полный набор конфликтов для генерации более осмысленных сообщений об ошибках, в отличие от «жадного» подхода, который останавливается на первой же ошибке.
\end{enumerate}
Использование паттерна TTG также анализируется как необходимое условие для интеграции с современными инструментами, такими как LSP, обеспечивая типобезопасное аннотирование АСД.

\textbf{Качественная оценка.} Система оценивается по характеристикам стандарта ISO 25010 \cite{iso-25010}. Высокая \textbf{модульность}, \textbf{анализируемость} (благодаря чёткой обработке ошибок) и \textbf{устанавливаемость} (благодаря Nix) подтверждают, что проект достиг своих целей как воспроизводимый и понятный учебный артефакт.

\textbf{Ограничения и направления для будущей работы.} Честно признаются ограничения проекта, которые одновременно служат дорожной картой для дальнейшего развития:
\begin{enumerate}
    \item \textbf{Отсутствие \texttt{let}-обобщения:} Наиболее значительное функциональное ограничение. Будущая работа может включать добавление локального решения ограничений для обобщения типов в \texttt{let}-связываниях.
    \item \textbf{Нетипизированное ядро:} Переход к типизированному промежуточному языку (Core) стал бы крупным шагом вперёд, обеспечив сквозную типобезопасность всего конвейера.
    \item \textbf{Упрощённый решатель ограничений:} Текущий решатель останавливается на первой ошибке. Его можно было бы усовершенствовать для обработки более сложных сценариев (например, «продвижение» ограничений) и составления отчёта обо всех нерешённых ограничениях.
\end{enumerate}

Анализ подтверждает, что \Arralac является не просто перереализацией, а модернизацией идей из фундаментальной литературы, успешно выполняя свою педагогическую миссию.

\newpage

\section*{Заключение}

Данная диссертация была мотивирована стремлением преодолеть педагогический разрыв между теорией продвинутых систем типов и практикой их реализации. Центральный тезис заключался в том, что этот разрыв можно эффективно сократить с помощью современного, ориентированного на обучение компилятора, который делает инженерные принципы систем вроде GHC осязаемыми и интерактивными. Проектирование и реализация \Arralac подтвердили этот тезис.

Ключевым результатом работы стало понимание того, что архитектурные решения, принимаемые при проектировании компилятора, напрямую влияют на его педагогическую ценность. Разделение генерации и решения ограничений не просто улучшает модульность — оно создаёт явное представление о «рассуждениях» тайпчекера, которое легче инспектировать и понимать. Аналогично, использование LSP подтверждает, что современные инструменты являются преобразующим элементом в образовании.

\Arralac успешно демонстрирует свою основную идею, но его путь как практического инструмента далёк от завершения. Логичными следующими шагами являются реализация \texttt{let}-обобщения, переход на типизированное ядро и расширение функциональности LSP.

В начале работы была поставлена цель «демистифицировать магию» промышленной системы типов. Реализация \Arralac показала, что ключевые принципы полиморфизма произвольных рангов могут быть воплощены в структурированном, современном и понятном виде. Объединяя фундаментальную теорию с практическими архитектурными паттернами, эта работа предоставляет ясный и интерактивный мост для студентов, исследователей и начинающих разработчиков языков. Данный проект служит подтверждением идеи, что даже самые мощные компиляторные технологии можно сделать доступными, способствуя более глубокому пониманию искусства реализации языков программирования.

Важно ещё раз подчеркнуть, что основная ценность данной работы заключается не в создании новой технологии или алгоритма, а в синтезе и дидактическом представлении существующих передовых практик для образовательных целей.
