module Language.Arralac.Interpreter.FreeFoil where

import Control.Monad.Foil (CoSinkable (..), DistinctEvidence (..), ExtEvidence (..))
import Control.Monad.Foil.Internal (DExt, Name (..), NameBinder (..), Scope (..), SinkableK, Substitution (..), unsafeDistinct, unsafeExt)
import Data.IntMap qualified as IntMap
import Data.IntSet qualified as IntSet
import Generics.Kind.TH
import Language.Arralac.Prelude.Pretty (Pretty' (..))
import Language.Arralac.Prelude.Unique (Unique (..))
import Language.Arralac.Syntax.Local.Name qualified as BT
import Unsafe.Coerce (unsafeCoerce)

-- | A wrapper around 'NameBinder' that stores additional information.
data CoreNameBinder n l
  = CoreNameBinder
  { name :: BT.Name
  , nameBinder :: (NameBinder n l)
  }

deriveGenericK 'CoreNameBinder

-- ** Extending scopes

-- | \(O(\min(n,W))\).
-- Extend a scope with one name (safely).
-- Note that as long as the foil is used as intended,
-- the name binder is guaranteed to introduce a name
-- that does not appear in the initial scope.
extendScope :: CoreNameBinder n l -> Scope n -> Scope l
extendScope CoreNameBinder{nameBinder = UnsafeNameBinder (UnsafeName name)} (UnsafeScope scope) =
  UnsafeScope (IntSet.insert name scope)

-- ** Refreshing binders

-- TODO check scope

-- | Allocate a fresh binder for a given scope.
withFreshBinderUsingUnique ::
  Scope n ->
  BT.Name ->
  (forall l. CoreNameBinder n l -> r) ->
  r
withFreshBinderUsingUnique (UnsafeScope _scope) name cont =
  cont binder
 where
  binder =
    CoreNameBinder
      { name
      , nameBinder = UnsafeNameBinder (UnsafeName (name.nameUnique.unique))
      }

-- | Unsafely declare that a given name (binder)
-- is already fresh in any scope @n'@.
unsafeAssertFresh ::
  forall n l n' l' r.
  CoreNameBinder n l ->
  ((DExt n' l') => CoreNameBinder n' l' -> r) ->
  r
unsafeAssertFresh binder cont =
  case unsafeDistinct @l' of
    Distinct -> case unsafeExt @n' @l' of
      Ext -> cont (unsafeCoerce binder)

-- | Safely produce a fresh name binder with respect to a given scope.
withFreshUsingUnique ::
  Scope n ->
  BT.Name ->
  (forall l. (DExt n l) => CoreNameBinder n l -> r) ->
  r
withFreshUsingUnique scope name cont = withFreshBinderUsingUnique scope name (`unsafeAssertFresh` cont)

-- * Safe substitions

-- | Extend substitution with a particular mapping.
addSubst ::
  Substitution e i o ->
  CoreNameBinder i i' ->
  e o ->
  Substitution e i' o
addSubst
  (UnsafeSubstitution env)
  (CoreNameBinder{nameBinder = UnsafeNameBinder (UnsafeName name')})
  ex =
    UnsafeSubstitution (IntMap.insert name' ex env)

instance CoSinkable CoreNameBinder where
  coSinkabilityProof _rename CoreNameBinder{name, nameBinder = UnsafeNameBinder name'} cont =
    cont unsafeCoerce CoreNameBinder{name, nameBinder = UnsafeNameBinder name'}

  withPattern f _ _ scope coreNameBinder coercion =
    (f scope coreNameBinder.nameBinder)
      (\x y -> coercion x CoreNameBinder{name = error "Impossible!", nameBinder = y})

instance SinkableK CoreNameBinder

newtype PrettyName n = PrettyName (Name n)

newtype PrettyNameBinder n l = PrettyNameBinder (NameBinder n l)

instance Pretty' (PrettyName n) where
  pretty' (PrettyName (UnsafeName n)) = "x_" <> pretty' n

instance Pretty' (PrettyNameBinder n l) where
  pretty' (PrettyNameBinder (UnsafeNameBinder name)) = pretty' (PrettyName name)

instance Pretty' (CoreNameBinder n l) where
  pretty' binder = pretty' (PrettyNameBinder binder.nameBinder)

-- TODO allow bind

-- -- | Scoped term under a (single) name binder.
-- data ScopedAST binder sig n where
--   ScopedAST :: binder n l -> AST binder sig l -> ScopedAST binder sig n

-- -- | A term, generated by a signature 'Bifunctor' @sig@,
-- -- with (free) variables in scope @n@.
-- data AST binder sig (n :: S) where
--   -- | A (free) variable in scope @n@.
--   Var :: (HasName binder) => binder n n -> AST binder sig n
--   -- | A non-variable syntactic construction specified by the signature 'Bifunctor' @sig@.
--   Node :: sig (ScopedAST binder sig n) (AST binder sig n) -> AST binder sig n

-- class HasName (a :: S -> S -> Type) where
--   getName :: a n n -> Name n

-- -- | Safely rename (if necessary) a given name to extend a given scope.
-- -- This is similar to 'withFresh', except if the name does not clash with
-- -- the scope, it can be used immediately, without renaming.
-- withRefreshed ::
--   -- | Ambient scope.
--   Scope o ->
--   BT.Name ->
--   -- | Name to refresh (if it clashes with the ambient scope).
--   Name i ->
--   -- | Continuation, accepting the refreshed name.
--   (forall o'. (DExt o o') => CoreNameBinder o o' -> r) ->
--   r
-- withRefreshed scope@(UnsafeScope rawScope) name' name@(UnsafeName rawName) cont
--   | IntSet.member rawName rawScope = withFreshUsingUnique scope name' cont
--   | otherwise = unsafeAssertFresh CoreNameBinder{name = name', nameBinder = (UnsafeNameBinder name)} cont

-- -- | Safely rename (if necessary) a given pattern to extend a given scope.
-- -- This is similar to 'withFreshPattern', except if a name in the pattern
-- -- does not clash with the scope, it can be used immediately, without renaming.
-- --
-- -- This is a more general version of 'withRefreshed'.
-- withRefreshedPattern ::
--   (Foil.Distinct o, CoSinkable pattern, Sinkable e, InjectName e) =>
--   -- | Ambient scope.
--   Scope o ->
--   -- | Pattern to refresh (if it clashes with the ambient scope).
--   pattern n l ->
--   -- | Continuation, accepting the refreshed pattern.
--   (forall o'. (DExt o o') => (Substitution e n o -> Substitution e l o') -> pattern o o' -> r) ->
--   r
-- withRefreshedPattern scope pattern cont =
--   withPattern
--     ( \scope' binder f ->
--         withRefreshed
--           scope'
--           pattern
--           (nameOf binder)
--           (\binder' -> f (WithRefreshedPattern (\subst -> addRename (sink subst) binder (nameOf binder'))) binder')
--     )
--     idWithRefreshedPattern
--     compWithRefreshedPattern
--     scope
--     pattern
--     (\(WithRefreshedPattern f) pattern' -> cont f pattern')

-- -- -- | Substitution for free (scoped monads).
-- substitute
--   ::
--   forall (i :: S) sig o binder.
--   (Bifunctor sig, Foil.Distinct o, Foil.CoSinkable binder)
--   => Foil.Scope o
--   -> Foil.Substitution (AST binder sig) i o
--   -> AST binder sig i
--   -> AST binder sig o
-- substitute scope subst = \case
--   Var name -> Foil.lookupSubst subst (getName name)
--   Node node -> Node (bimap f (substitute scope subst) node)
--   where
--     f (ScopedAST binder body) =
--       withRefreshedPattern scope binder $ \extendSubst binder' ->
--         let subst' = extendSubst (Foil.sink subst)
--             scope' = Foil.extendScopePattern binder' scope
--             body' = substitute scope' subst' body
--         in ScopedAST binder' body'
