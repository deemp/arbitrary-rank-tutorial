-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.STLC.Syntax.Par
  ( happyError
  , myLexer
  , pProgram
  , pVar
  , pExp1
  , pExp2
  , pExp3
  , pExp4
  , pExp5
  , pExp6
  , pExp7
  , pExp
  , pExp10
  , pExp11
  , pType1
  , pType2
  , pType3
  , pTypeVariable
  , pType4
  , pListTypeVariable
  , pType
  ) where

import Prelude

import qualified Language.STLC.Syntax.Abs
import Language.STLC.Syntax.Lex
import qualified Data.Text

}

%name pProgram_internal Program
%name pVar_internal Var
%name pExp1_internal Exp1
%name pExp2_internal Exp2
%name pExp3_internal Exp3
%name pExp4_internal Exp4
%name pExp5_internal Exp5
%name pExp6_internal Exp6
%name pExp7_internal Exp7
%name pExp_internal Exp
%name pExp10_internal Exp10
%name pExp11_internal Exp11
%name pType1_internal Type1
%name pType2_internal Type2
%name pType3_internal Type3
%name pTypeVariable_internal TypeVariable
%name pType4_internal Type4
%name pListTypeVariable_internal ListTypeVariable
%name pType_internal Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('             { PT _ (TS _ 1)            }
  ')'             { PT _ (TS _ 2)            }
  '->'            { PT _ (TS _ 3)            }
  '.'             { PT _ (TS _ 4)            }
  '::'            { PT _ (TS _ 5)            }
  '='             { PT _ (TS _ 6)            }
  '\\'            { PT _ (TS _ 7)            }
  'forall'        { PT _ (TS _ 8)            }
  'in'            { PT _ (TS _ 9)            }
  'let'           { PT _ (TS _ 10)           }
  L_integ         { PT _ (TI _)              }
  L_quoted        { PT _ (TL _)              }
  L_NameLowerCase { PT _ (T_NameLowerCase _) }
  L_NameUpperCase { PT _ (T_NameUpperCase _) }

%%

Integer :: { (Language.STLC.Syntax.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (read (Data.Text.unpack (tokenText $1))) :: Integer) }

String  :: { (Language.STLC.Syntax.Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (Data.Text.unpack ((\(PT _ (TL s)) -> s) $1))) }

NameLowerCase :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.NameLowerCase) }
NameLowerCase  : L_NameLowerCase { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.NameLowerCase (tokenText $1)) }

NameUpperCase :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.NameUpperCase) }
NameUpperCase  : L_NameUpperCase { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.NameUpperCase (tokenText $1)) }

Program :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Program) }
Program
  : Exp { (fst $1, Language.STLC.Syntax.Abs.Program (fst $1) (snd $1)) }

Var :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Var) }
Var
  : NameLowerCase { (fst $1, Language.STLC.Syntax.Abs.Var (fst $1) (snd $1)) }

Exp1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp1
  : Var { (fst $1, Language.STLC.Syntax.Abs.ExpVar (fst $1) (snd $1)) }

Exp2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp2
  : Integer { (fst $1, Language.STLC.Syntax.Abs.ExpInt (fst $1) (snd $1)) }
  | String { (fst $1, Language.STLC.Syntax.Abs.ExpString (fst $1) (snd $1)) }

Exp3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp3
  : '\\' Var '.' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpAbs (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

Exp4 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp4
  : '\\' '(' Var '::' Type ')' '.' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpAbsAnno (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $8)) }

Exp5 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp5
  : Exp11 Exp10 { (fst $1, Language.STLC.Syntax.Abs.ExpApp (fst $1) (snd $1) (snd $2)) }

Exp6 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp6
  : 'let' Var '=' Exp 'in' Exp { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ExpLet (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }

Exp7 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp7
  : Exp '::' Type { (fst $1, Language.STLC.Syntax.Abs.ExpAnno (fst $1) (snd $1) (snd $3)) }

Exp :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp
  : Exp1 { (fst $1, (snd $1)) }
  | Exp2 { (fst $1, (snd $1)) }
  | Exp3 { (fst $1, (snd $1)) }
  | Exp4 { (fst $1, (snd $1)) }
  | Exp5 { (fst $1, (snd $1)) }
  | Exp6 { (fst $1, (snd $1)) }
  | Exp7 { (fst $1, (snd $1)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp10 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp10
  : Exp1 { (fst $1, (snd $1)) }
  | Exp2 { (fst $1, (snd $1)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp11 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Exp) }
Exp11
  : Exp1 { (fst $1, (snd $1)) }
  | Exp5 { (fst $1, (snd $1)) }
  | '(' Exp ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type1
  : NameUpperCase { (fst $1, Language.STLC.Syntax.Abs.TypeConcrete (fst $1) (snd $1)) }

Type2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type2
  : NameLowerCase { (fst $1, Language.STLC.Syntax.Abs.TypeVariable (fst $1) (snd $1)) }

Type3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type3
  : Type3 '->' Type3 { (fst $1, Language.STLC.Syntax.Abs.TypeFunc (fst $1) (snd $1) (snd $3)) }
  | Type1 { (fst $1, (snd $1)) }
  | Type2 { (fst $1, (snd $1)) }
  | Type4 { (fst $1, (snd $1)) }
  | '(' Type3 ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

TypeVariable :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.TypeVariable) }
TypeVariable
  : NameLowerCase { (fst $1, Language.STLC.Syntax.Abs.TypeVariableName (fst $1) (snd $1)) }

Type4 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type4
  : 'forall' ListTypeVariable '.' Type3 { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TypeForall (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListTypeVariable :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.TypeVariable]) }
ListTypeVariable
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | TypeVariable ListTypeVariable { (fst $1, (:) (snd $1) (snd $2)) }

Type :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type
  : Type1 { (fst $1, (snd $1)) }
  | Type2 { (fst $1, (snd $1)) }
  | Type3 { (fst $1, (snd $1)) }
  | Type4 { (fst $1, (snd $1)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Language.STLC.Syntax.Abs.Program
pProgram = fmap snd . pProgram_internal

pVar :: [Token] -> Err Language.STLC.Syntax.Abs.Var
pVar = fmap snd . pVar_internal

pExp1 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp1 = fmap snd . pExp1_internal

pExp2 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp2 = fmap snd . pExp2_internal

pExp3 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp3 = fmap snd . pExp3_internal

pExp4 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp4 = fmap snd . pExp4_internal

pExp5 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp5 = fmap snd . pExp5_internal

pExp6 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp6 = fmap snd . pExp6_internal

pExp7 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp7 = fmap snd . pExp7_internal

pExp :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp = fmap snd . pExp_internal

pExp10 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp10 = fmap snd . pExp10_internal

pExp11 :: [Token] -> Err Language.STLC.Syntax.Abs.Exp
pExp11 = fmap snd . pExp11_internal

pType1 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType1 = fmap snd . pType1_internal

pType2 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType2 = fmap snd . pType2_internal

pType3 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType3 = fmap snd . pType3_internal

pTypeVariable :: [Token] -> Err Language.STLC.Syntax.Abs.TypeVariable
pTypeVariable = fmap snd . pTypeVariable_internal

pType4 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType4 = fmap snd . pType4_internal

pListTypeVariable :: [Token] -> Err [Language.STLC.Syntax.Abs.TypeVariable]
pListTypeVariable = fmap snd . pListTypeVariable_internal

pType :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType = fmap snd . pType_internal
}

